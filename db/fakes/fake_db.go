// This file was generated by counterfeiter
package fakes

import (
	"sync"
	"time"

	"github.com/cloudfoundry-incubator/auctioneer"
	"github.com/cloudfoundry-incubator/bbs/db"
	"github.com/cloudfoundry-incubator/bbs/models"
	"github.com/pivotal-golang/lager"
)

type FakeDB struct {
	DomainsStub        func(logger lager.Logger) ([]string, error)
	domainsMutex       sync.RWMutex
	domainsArgsForCall []struct {
		logger lager.Logger
	}
	domainsReturns struct {
		result1 []string
		result2 error
	}
	UpsertDomainStub        func(lgger lager.Logger, domain string, ttl uint32) error
	upsertDomainMutex       sync.RWMutex
	upsertDomainArgsForCall []struct {
		lgger  lager.Logger
		domain string
		ttl    uint32
	}
	upsertDomainReturns struct {
		result1 error
	}
	EncryptionKeyLabelStub        func(logger lager.Logger) (string, error)
	encryptionKeyLabelMutex       sync.RWMutex
	encryptionKeyLabelArgsForCall []struct {
		logger lager.Logger
	}
	encryptionKeyLabelReturns struct {
		result1 string
		result2 error
	}
	SetEncryptionKeyLabelStub        func(logger lager.Logger, encryptionKeyLabel string) error
	setEncryptionKeyLabelMutex       sync.RWMutex
	setEncryptionKeyLabelArgsForCall []struct {
		logger             lager.Logger
		encryptionKeyLabel string
	}
	setEncryptionKeyLabelReturns struct {
		result1 error
	}
	RemoveEvacuatingActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error
	removeEvacuatingActualLRPMutex       sync.RWMutex
	removeEvacuatingActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}
	removeEvacuatingActualLRPReturns struct {
		result1 error
	}
	EvacuateActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo, uint64) error
	evacuateActualLRPMutex       sync.RWMutex
	evacuateActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 *models.ActualLRPNetInfo
		arg5 uint64
	}
	evacuateActualLRPReturns struct {
		result1 error
	}
	WatchForActualLRPChangesStub        func(lager.Logger, func(created *models.ActualLRPGroup), func(changed *models.ActualLRPChange), func(deleted *models.ActualLRPGroup)) (chan<- bool, <-chan error)
	watchForActualLRPChangesMutex       sync.RWMutex
	watchForActualLRPChangesArgsForCall []struct {
		arg1 lager.Logger
		arg2 func(created *models.ActualLRPGroup)
		arg3 func(changed *models.ActualLRPChange)
		arg4 func(deleted *models.ActualLRPGroup)
	}
	watchForActualLRPChangesReturns struct {
		result1 chan<- bool
		result2 <-chan error
	}
	WatchForDesiredLRPChangesStub        func(lager.Logger, func(created *models.DesiredLRP), func(changed *models.DesiredLRPChange), func(deleted *models.DesiredLRP)) (chan<- bool, <-chan error)
	watchForDesiredLRPChangesMutex       sync.RWMutex
	watchForDesiredLRPChangesArgsForCall []struct {
		arg1 lager.Logger
		arg2 func(created *models.DesiredLRP)
		arg3 func(changed *models.DesiredLRPChange)
		arg4 func(deleted *models.DesiredLRP)
	}
	watchForDesiredLRPChangesReturns struct {
		result1 chan<- bool
		result2 <-chan error
	}
	WatchForTaskChangesStub        func(lager.Logger, func(created *models.Task), func(changed *models.TaskChange), func(deleted *models.Task)) (chan<- bool, <-chan error)
	watchForTaskChangesMutex       sync.RWMutex
	watchForTaskChangesArgsForCall []struct {
		arg1 lager.Logger
		arg2 func(created *models.Task)
		arg3 func(changed *models.TaskChange)
		arg4 func(deleted *models.Task)
	}
	watchForTaskChangesReturns struct {
		result1 chan<- bool
		result2 <-chan error
	}
	ActualLRPGroupsStub        func(logger lager.Logger, filter models.ActualLRPFilter) ([]*models.ActualLRPGroup, error)
	actualLRPGroupsMutex       sync.RWMutex
	actualLRPGroupsArgsForCall []struct {
		logger lager.Logger
		filter models.ActualLRPFilter
	}
	actualLRPGroupsReturns struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	ActualLRPGroupsByProcessGuidStub        func(logger lager.Logger, processGuid string) ([]*models.ActualLRPGroup, error)
	actualLRPGroupsByProcessGuidMutex       sync.RWMutex
	actualLRPGroupsByProcessGuidArgsForCall []struct {
		logger      lager.Logger
		processGuid string
	}
	actualLRPGroupsByProcessGuidReturns struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	ActualLRPGroupByProcessGuidAndIndexStub        func(logger lager.Logger, processGuid string, index int32) (*models.ActualLRPGroup, error)
	actualLRPGroupByProcessGuidAndIndexMutex       sync.RWMutex
	actualLRPGroupByProcessGuidAndIndexArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int32
	}
	actualLRPGroupByProcessGuidAndIndexReturns struct {
		result1 *models.ActualLRPGroup
		result2 error
	}
	CreateUnclaimedActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey) error
	createUnclaimedActualLRPMutex       sync.RWMutex
	createUnclaimedActualLRPArgsForCall []struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}
	createUnclaimedActualLRPReturns struct {
		result1 error
	}
	UnclaimActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey) error
	unclaimActualLRPMutex       sync.RWMutex
	unclaimActualLRPArgsForCall []struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}
	unclaimActualLRPReturns struct {
		result1 error
	}
	ClaimActualLRPStub        func(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) error
	claimActualLRPMutex       sync.RWMutex
	claimActualLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}
	claimActualLRPReturns struct {
		result1 error
	}
	StartActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, netInfo *models.ActualLRPNetInfo) error
	startActualLRPMutex       sync.RWMutex
	startActualLRPArgsForCall []struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		netInfo     *models.ActualLRPNetInfo
	}
	startActualLRPReturns struct {
		result1 error
	}
	CrashActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, crashReason string) (shouldRestart bool, err error)
	crashActualLRPMutex       sync.RWMutex
	crashActualLRPArgsForCall []struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		crashReason string
	}
	crashActualLRPReturns struct {
		result1 bool
		result2 error
	}
	FailActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, placementError string) error
	failActualLRPMutex       sync.RWMutex
	failActualLRPArgsForCall []struct {
		logger         lager.Logger
		key            *models.ActualLRPKey
		placementError string
	}
	failActualLRPReturns struct {
		result1 error
	}
	RemoveActualLRPStub        func(logger lager.Logger, processGuid string, index int32) error
	removeActualLRPMutex       sync.RWMutex
	removeActualLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int32
	}
	removeActualLRPReturns struct {
		result1 error
	}
	DesiredLRPsStub        func(logger lager.Logger, filter models.DesiredLRPFilter) ([]*models.DesiredLRP, error)
	desiredLRPsMutex       sync.RWMutex
	desiredLRPsArgsForCall []struct {
		logger lager.Logger
		filter models.DesiredLRPFilter
	}
	desiredLRPsReturns struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	DesiredLRPByProcessGuidStub        func(logger lager.Logger, processGuid string) (*models.DesiredLRP, error)
	desiredLRPByProcessGuidMutex       sync.RWMutex
	desiredLRPByProcessGuidArgsForCall []struct {
		logger      lager.Logger
		processGuid string
	}
	desiredLRPByProcessGuidReturns struct {
		result1 *models.DesiredLRP
		result2 error
	}
	DesiredLRPSchedulingInfosStub        func(logger lager.Logger, filter models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error)
	desiredLRPSchedulingInfosMutex       sync.RWMutex
	desiredLRPSchedulingInfosArgsForCall []struct {
		logger lager.Logger
		filter models.DesiredLRPFilter
	}
	desiredLRPSchedulingInfosReturns struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}
	DesireLRPStub        func(logger lager.Logger, desiredLRP *models.DesiredLRP) error
	desireLRPMutex       sync.RWMutex
	desireLRPArgsForCall []struct {
		logger     lager.Logger
		desiredLRP *models.DesiredLRP
	}
	desireLRPReturns struct {
		result1 error
	}
	UpdateDesiredLRPStub        func(logger lager.Logger, processGuid string, update *models.DesiredLRPUpdate) (previousInstanceCount int32, err error)
	updateDesiredLRPMutex       sync.RWMutex
	updateDesiredLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		update      *models.DesiredLRPUpdate
	}
	updateDesiredLRPReturns struct {
		result1 int32
		result2 error
	}
	RemoveDesiredLRPStub        func(logger lager.Logger, processGuid string) error
	removeDesiredLRPMutex       sync.RWMutex
	removeDesiredLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
	}
	removeDesiredLRPReturns struct {
		result1 error
	}
	ConvergeLRPsStub        func(logger lager.Logger) (keysToAuction []*auctioneer.LRPStartRequest, keysToRetire []*models.ActualLRPKey)
	convergeLRPsMutex       sync.RWMutex
	convergeLRPsArgsForCall []struct {
		logger lager.Logger
	}
	convergeLRPsReturns struct {
		result1 []*auctioneer.LRPStartRequest
		result2 []*models.ActualLRPKey
	}
	GatherAndPruneLRPsStub        func(logger lager.Logger) (*models.ConvergenceInput, error)
	gatherAndPruneLRPsMutex       sync.RWMutex
	gatherAndPruneLRPsArgsForCall []struct {
		logger lager.Logger
	}
	gatherAndPruneLRPsReturns struct {
		result1 *models.ConvergenceInput
		result2 error
	}
	TasksStub        func(logger lager.Logger, filter models.TaskFilter) ([]*models.Task, error)
	tasksMutex       sync.RWMutex
	tasksArgsForCall []struct {
		logger lager.Logger
		filter models.TaskFilter
	}
	tasksReturns struct {
		result1 []*models.Task
		result2 error
	}
	TaskByGuidStub        func(logger lager.Logger, taskGuid string) (*models.Task, error)
	taskByGuidMutex       sync.RWMutex
	taskByGuidArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	taskByGuidReturns struct {
		result1 *models.Task
		result2 error
	}
	DesireTaskStub        func(logger lager.Logger, taskDefinition *models.TaskDefinition, taskGuid, domain string) error
	desireTaskMutex       sync.RWMutex
	desireTaskArgsForCall []struct {
		logger         lager.Logger
		taskDefinition *models.TaskDefinition
		taskGuid       string
		domain         string
	}
	desireTaskReturns struct {
		result1 error
	}
	StartTaskStub        func(logger lager.Logger, taskGuid, cellId string) (bool, error)
	startTaskMutex       sync.RWMutex
	startTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
		cellId   string
	}
	startTaskReturns struct {
		result1 bool
		result2 error
	}
	CancelTaskStub        func(logger lager.Logger, taskGuid string) (task *models.Task, err error)
	cancelTaskMutex       sync.RWMutex
	cancelTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	cancelTaskReturns struct {
		result1 *models.Task
		result2 error
	}
	FailTaskStub        func(logger lager.Logger, taskGuid, failureReason string) (task *models.Task, err error)
	failTaskMutex       sync.RWMutex
	failTaskArgsForCall []struct {
		logger        lager.Logger
		taskGuid      string
		failureReason string
	}
	failTaskReturns struct {
		result1 *models.Task
		result2 error
	}
	CompleteTaskStub        func(logger lager.Logger, taskGuid, cellId string, failed bool, failureReason, result string) (task *models.Task, err error)
	completeTaskMutex       sync.RWMutex
	completeTaskArgsForCall []struct {
		logger        lager.Logger
		taskGuid      string
		cellId        string
		failed        bool
		failureReason string
		result        string
	}
	completeTaskReturns struct {
		result1 *models.Task
		result2 error
	}
	ResolvingTaskStub        func(logger lager.Logger, taskGuid string) error
	resolvingTaskMutex       sync.RWMutex
	resolvingTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	resolvingTaskReturns struct {
		result1 error
	}
	DeleteTaskStub        func(logger lager.Logger, taskGuid string) error
	deleteTaskMutex       sync.RWMutex
	deleteTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	deleteTaskReturns struct {
		result1 error
	}
	ConvergeTasksStub        func(logger lager.Logger, kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration time.Duration)
	convergeTasksMutex       sync.RWMutex
	convergeTasksArgsForCall []struct {
		logger                      lager.Logger
		kickTaskDuration            time.Duration
		expirePendingTaskDuration   time.Duration
		expireCompletedTaskDuration time.Duration
	}
	VersionStub        func(logger lager.Logger) (*models.Version, error)
	versionMutex       sync.RWMutex
	versionArgsForCall []struct {
		logger lager.Logger
	}
	versionReturns struct {
		result1 *models.Version
		result2 error
	}
	SetVersionStub        func(logger lager.Logger, version *models.Version) error
	setVersionMutex       sync.RWMutex
	setVersionArgsForCall []struct {
		logger  lager.Logger
		version *models.Version
	}
	setVersionReturns struct {
		result1 error
	}
}

func (fake *FakeDB) Domains(logger lager.Logger) ([]string, error) {
	fake.domainsMutex.Lock()
	fake.domainsArgsForCall = append(fake.domainsArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.domainsMutex.Unlock()
	if fake.DomainsStub != nil {
		return fake.DomainsStub(logger)
	} else {
		return fake.domainsReturns.result1, fake.domainsReturns.result2
	}
}

func (fake *FakeDB) DomainsCallCount() int {
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	return len(fake.domainsArgsForCall)
}

func (fake *FakeDB) DomainsArgsForCall(i int) lager.Logger {
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	return fake.domainsArgsForCall[i].logger
}

func (fake *FakeDB) DomainsReturns(result1 []string, result2 error) {
	fake.DomainsStub = nil
	fake.domainsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) UpsertDomain(lgger lager.Logger, domain string, ttl uint32) error {
	fake.upsertDomainMutex.Lock()
	fake.upsertDomainArgsForCall = append(fake.upsertDomainArgsForCall, struct {
		lgger  lager.Logger
		domain string
		ttl    uint32
	}{lgger, domain, ttl})
	fake.upsertDomainMutex.Unlock()
	if fake.UpsertDomainStub != nil {
		return fake.UpsertDomainStub(lgger, domain, ttl)
	} else {
		return fake.upsertDomainReturns.result1
	}
}

func (fake *FakeDB) UpsertDomainCallCount() int {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	return len(fake.upsertDomainArgsForCall)
}

func (fake *FakeDB) UpsertDomainArgsForCall(i int) (lager.Logger, string, uint32) {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	return fake.upsertDomainArgsForCall[i].lgger, fake.upsertDomainArgsForCall[i].domain, fake.upsertDomainArgsForCall[i].ttl
}

func (fake *FakeDB) UpsertDomainReturns(result1 error) {
	fake.UpsertDomainStub = nil
	fake.upsertDomainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) EncryptionKeyLabel(logger lager.Logger) (string, error) {
	fake.encryptionKeyLabelMutex.Lock()
	fake.encryptionKeyLabelArgsForCall = append(fake.encryptionKeyLabelArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.encryptionKeyLabelMutex.Unlock()
	if fake.EncryptionKeyLabelStub != nil {
		return fake.EncryptionKeyLabelStub(logger)
	} else {
		return fake.encryptionKeyLabelReturns.result1, fake.encryptionKeyLabelReturns.result2
	}
}

func (fake *FakeDB) EncryptionKeyLabelCallCount() int {
	fake.encryptionKeyLabelMutex.RLock()
	defer fake.encryptionKeyLabelMutex.RUnlock()
	return len(fake.encryptionKeyLabelArgsForCall)
}

func (fake *FakeDB) EncryptionKeyLabelArgsForCall(i int) lager.Logger {
	fake.encryptionKeyLabelMutex.RLock()
	defer fake.encryptionKeyLabelMutex.RUnlock()
	return fake.encryptionKeyLabelArgsForCall[i].logger
}

func (fake *FakeDB) EncryptionKeyLabelReturns(result1 string, result2 error) {
	fake.EncryptionKeyLabelStub = nil
	fake.encryptionKeyLabelReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) SetEncryptionKeyLabel(logger lager.Logger, encryptionKeyLabel string) error {
	fake.setEncryptionKeyLabelMutex.Lock()
	fake.setEncryptionKeyLabelArgsForCall = append(fake.setEncryptionKeyLabelArgsForCall, struct {
		logger             lager.Logger
		encryptionKeyLabel string
	}{logger, encryptionKeyLabel})
	fake.setEncryptionKeyLabelMutex.Unlock()
	if fake.SetEncryptionKeyLabelStub != nil {
		return fake.SetEncryptionKeyLabelStub(logger, encryptionKeyLabel)
	} else {
		return fake.setEncryptionKeyLabelReturns.result1
	}
}

func (fake *FakeDB) SetEncryptionKeyLabelCallCount() int {
	fake.setEncryptionKeyLabelMutex.RLock()
	defer fake.setEncryptionKeyLabelMutex.RUnlock()
	return len(fake.setEncryptionKeyLabelArgsForCall)
}

func (fake *FakeDB) SetEncryptionKeyLabelArgsForCall(i int) (lager.Logger, string) {
	fake.setEncryptionKeyLabelMutex.RLock()
	defer fake.setEncryptionKeyLabelMutex.RUnlock()
	return fake.setEncryptionKeyLabelArgsForCall[i].logger, fake.setEncryptionKeyLabelArgsForCall[i].encryptionKeyLabel
}

func (fake *FakeDB) SetEncryptionKeyLabelReturns(result1 error) {
	fake.SetEncryptionKeyLabelStub = nil
	fake.setEncryptionKeyLabelReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) RemoveEvacuatingActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey) error {
	fake.removeEvacuatingActualLRPMutex.Lock()
	fake.removeEvacuatingActualLRPArgsForCall = append(fake.removeEvacuatingActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3})
	fake.removeEvacuatingActualLRPMutex.Unlock()
	if fake.RemoveEvacuatingActualLRPStub != nil {
		return fake.RemoveEvacuatingActualLRPStub(arg1, arg2, arg3)
	} else {
		return fake.removeEvacuatingActualLRPReturns.result1
	}
}

func (fake *FakeDB) RemoveEvacuatingActualLRPCallCount() int {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	return len(fake.removeEvacuatingActualLRPArgsForCall)
}

func (fake *FakeDB) RemoveEvacuatingActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	return fake.removeEvacuatingActualLRPArgsForCall[i].arg1, fake.removeEvacuatingActualLRPArgsForCall[i].arg2, fake.removeEvacuatingActualLRPArgsForCall[i].arg3
}

func (fake *FakeDB) RemoveEvacuatingActualLRPReturns(result1 error) {
	fake.RemoveEvacuatingActualLRPStub = nil
	fake.removeEvacuatingActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) EvacuateActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey, arg4 *models.ActualLRPNetInfo, arg5 uint64) error {
	fake.evacuateActualLRPMutex.Lock()
	fake.evacuateActualLRPArgsForCall = append(fake.evacuateActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 *models.ActualLRPNetInfo
		arg5 uint64
	}{arg1, arg2, arg3, arg4, arg5})
	fake.evacuateActualLRPMutex.Unlock()
	if fake.EvacuateActualLRPStub != nil {
		return fake.EvacuateActualLRPStub(arg1, arg2, arg3, arg4, arg5)
	} else {
		return fake.evacuateActualLRPReturns.result1
	}
}

func (fake *FakeDB) EvacuateActualLRPCallCount() int {
	fake.evacuateActualLRPMutex.RLock()
	defer fake.evacuateActualLRPMutex.RUnlock()
	return len(fake.evacuateActualLRPArgsForCall)
}

func (fake *FakeDB) EvacuateActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo, uint64) {
	fake.evacuateActualLRPMutex.RLock()
	defer fake.evacuateActualLRPMutex.RUnlock()
	return fake.evacuateActualLRPArgsForCall[i].arg1, fake.evacuateActualLRPArgsForCall[i].arg2, fake.evacuateActualLRPArgsForCall[i].arg3, fake.evacuateActualLRPArgsForCall[i].arg4, fake.evacuateActualLRPArgsForCall[i].arg5
}

func (fake *FakeDB) EvacuateActualLRPReturns(result1 error) {
	fake.EvacuateActualLRPStub = nil
	fake.evacuateActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) WatchForActualLRPChanges(arg1 lager.Logger, arg2 func(created *models.ActualLRPGroup), arg3 func(changed *models.ActualLRPChange), arg4 func(deleted *models.ActualLRPGroup)) (chan<- bool, <-chan error) {
	fake.watchForActualLRPChangesMutex.Lock()
	fake.watchForActualLRPChangesArgsForCall = append(fake.watchForActualLRPChangesArgsForCall, struct {
		arg1 lager.Logger
		arg2 func(created *models.ActualLRPGroup)
		arg3 func(changed *models.ActualLRPChange)
		arg4 func(deleted *models.ActualLRPGroup)
	}{arg1, arg2, arg3, arg4})
	fake.watchForActualLRPChangesMutex.Unlock()
	if fake.WatchForActualLRPChangesStub != nil {
		return fake.WatchForActualLRPChangesStub(arg1, arg2, arg3, arg4)
	} else {
		return fake.watchForActualLRPChangesReturns.result1, fake.watchForActualLRPChangesReturns.result2
	}
}

func (fake *FakeDB) WatchForActualLRPChangesCallCount() int {
	fake.watchForActualLRPChangesMutex.RLock()
	defer fake.watchForActualLRPChangesMutex.RUnlock()
	return len(fake.watchForActualLRPChangesArgsForCall)
}

func (fake *FakeDB) WatchForActualLRPChangesArgsForCall(i int) (lager.Logger, func(created *models.ActualLRPGroup), func(changed *models.ActualLRPChange), func(deleted *models.ActualLRPGroup)) {
	fake.watchForActualLRPChangesMutex.RLock()
	defer fake.watchForActualLRPChangesMutex.RUnlock()
	return fake.watchForActualLRPChangesArgsForCall[i].arg1, fake.watchForActualLRPChangesArgsForCall[i].arg2, fake.watchForActualLRPChangesArgsForCall[i].arg3, fake.watchForActualLRPChangesArgsForCall[i].arg4
}

func (fake *FakeDB) WatchForActualLRPChangesReturns(result1 chan<- bool, result2 <-chan error) {
	fake.WatchForActualLRPChangesStub = nil
	fake.watchForActualLRPChangesReturns = struct {
		result1 chan<- bool
		result2 <-chan error
	}{result1, result2}
}

func (fake *FakeDB) WatchForDesiredLRPChanges(arg1 lager.Logger, arg2 func(created *models.DesiredLRP), arg3 func(changed *models.DesiredLRPChange), arg4 func(deleted *models.DesiredLRP)) (chan<- bool, <-chan error) {
	fake.watchForDesiredLRPChangesMutex.Lock()
	fake.watchForDesiredLRPChangesArgsForCall = append(fake.watchForDesiredLRPChangesArgsForCall, struct {
		arg1 lager.Logger
		arg2 func(created *models.DesiredLRP)
		arg3 func(changed *models.DesiredLRPChange)
		arg4 func(deleted *models.DesiredLRP)
	}{arg1, arg2, arg3, arg4})
	fake.watchForDesiredLRPChangesMutex.Unlock()
	if fake.WatchForDesiredLRPChangesStub != nil {
		return fake.WatchForDesiredLRPChangesStub(arg1, arg2, arg3, arg4)
	} else {
		return fake.watchForDesiredLRPChangesReturns.result1, fake.watchForDesiredLRPChangesReturns.result2
	}
}

func (fake *FakeDB) WatchForDesiredLRPChangesCallCount() int {
	fake.watchForDesiredLRPChangesMutex.RLock()
	defer fake.watchForDesiredLRPChangesMutex.RUnlock()
	return len(fake.watchForDesiredLRPChangesArgsForCall)
}

func (fake *FakeDB) WatchForDesiredLRPChangesArgsForCall(i int) (lager.Logger, func(created *models.DesiredLRP), func(changed *models.DesiredLRPChange), func(deleted *models.DesiredLRP)) {
	fake.watchForDesiredLRPChangesMutex.RLock()
	defer fake.watchForDesiredLRPChangesMutex.RUnlock()
	return fake.watchForDesiredLRPChangesArgsForCall[i].arg1, fake.watchForDesiredLRPChangesArgsForCall[i].arg2, fake.watchForDesiredLRPChangesArgsForCall[i].arg3, fake.watchForDesiredLRPChangesArgsForCall[i].arg4
}

func (fake *FakeDB) WatchForDesiredLRPChangesReturns(result1 chan<- bool, result2 <-chan error) {
	fake.WatchForDesiredLRPChangesStub = nil
	fake.watchForDesiredLRPChangesReturns = struct {
		result1 chan<- bool
		result2 <-chan error
	}{result1, result2}
}

func (fake *FakeDB) WatchForTaskChanges(arg1 lager.Logger, arg2 func(created *models.Task), arg3 func(changed *models.TaskChange), arg4 func(deleted *models.Task)) (chan<- bool, <-chan error) {
	fake.watchForTaskChangesMutex.Lock()
	fake.watchForTaskChangesArgsForCall = append(fake.watchForTaskChangesArgsForCall, struct {
		arg1 lager.Logger
		arg2 func(created *models.Task)
		arg3 func(changed *models.TaskChange)
		arg4 func(deleted *models.Task)
	}{arg1, arg2, arg3, arg4})
	fake.watchForTaskChangesMutex.Unlock()
	if fake.WatchForTaskChangesStub != nil {
		return fake.WatchForTaskChangesStub(arg1, arg2, arg3, arg4)
	} else {
		return fake.watchForTaskChangesReturns.result1, fake.watchForTaskChangesReturns.result2
	}
}

func (fake *FakeDB) WatchForTaskChangesCallCount() int {
	fake.watchForTaskChangesMutex.RLock()
	defer fake.watchForTaskChangesMutex.RUnlock()
	return len(fake.watchForTaskChangesArgsForCall)
}

func (fake *FakeDB) WatchForTaskChangesArgsForCall(i int) (lager.Logger, func(created *models.Task), func(changed *models.TaskChange), func(deleted *models.Task)) {
	fake.watchForTaskChangesMutex.RLock()
	defer fake.watchForTaskChangesMutex.RUnlock()
	return fake.watchForTaskChangesArgsForCall[i].arg1, fake.watchForTaskChangesArgsForCall[i].arg2, fake.watchForTaskChangesArgsForCall[i].arg3, fake.watchForTaskChangesArgsForCall[i].arg4
}

func (fake *FakeDB) WatchForTaskChangesReturns(result1 chan<- bool, result2 <-chan error) {
	fake.WatchForTaskChangesStub = nil
	fake.watchForTaskChangesReturns = struct {
		result1 chan<- bool
		result2 <-chan error
	}{result1, result2}
}

func (fake *FakeDB) ActualLRPGroups(logger lager.Logger, filter models.ActualLRPFilter) ([]*models.ActualLRPGroup, error) {
	fake.actualLRPGroupsMutex.Lock()
	fake.actualLRPGroupsArgsForCall = append(fake.actualLRPGroupsArgsForCall, struct {
		logger lager.Logger
		filter models.ActualLRPFilter
	}{logger, filter})
	fake.actualLRPGroupsMutex.Unlock()
	if fake.ActualLRPGroupsStub != nil {
		return fake.ActualLRPGroupsStub(logger, filter)
	} else {
		return fake.actualLRPGroupsReturns.result1, fake.actualLRPGroupsReturns.result2
	}
}

func (fake *FakeDB) ActualLRPGroupsCallCount() int {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	return len(fake.actualLRPGroupsArgsForCall)
}

func (fake *FakeDB) ActualLRPGroupsArgsForCall(i int) (lager.Logger, models.ActualLRPFilter) {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	return fake.actualLRPGroupsArgsForCall[i].logger, fake.actualLRPGroupsArgsForCall[i].filter
}

func (fake *FakeDB) ActualLRPGroupsReturns(result1 []*models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupsStub = nil
	fake.actualLRPGroupsReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ActualLRPGroupsByProcessGuid(logger lager.Logger, processGuid string) ([]*models.ActualLRPGroup, error) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	fake.actualLRPGroupsByProcessGuidArgsForCall = append(fake.actualLRPGroupsByProcessGuidArgsForCall, struct {
		logger      lager.Logger
		processGuid string
	}{logger, processGuid})
	fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	if fake.ActualLRPGroupsByProcessGuidStub != nil {
		return fake.ActualLRPGroupsByProcessGuidStub(logger, processGuid)
	} else {
		return fake.actualLRPGroupsByProcessGuidReturns.result1, fake.actualLRPGroupsByProcessGuidReturns.result2
	}
}

func (fake *FakeDB) ActualLRPGroupsByProcessGuidCallCount() int {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	return len(fake.actualLRPGroupsByProcessGuidArgsForCall)
}

func (fake *FakeDB) ActualLRPGroupsByProcessGuidArgsForCall(i int) (lager.Logger, string) {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	return fake.actualLRPGroupsByProcessGuidArgsForCall[i].logger, fake.actualLRPGroupsByProcessGuidArgsForCall[i].processGuid
}

func (fake *FakeDB) ActualLRPGroupsByProcessGuidReturns(result1 []*models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupsByProcessGuidStub = nil
	fake.actualLRPGroupsByProcessGuidReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ActualLRPGroupByProcessGuidAndIndex(logger lager.Logger, processGuid string, index int32) (*models.ActualLRPGroup, error) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	fake.actualLRPGroupByProcessGuidAndIndexArgsForCall = append(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int32
	}{logger, processGuid, index})
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	if fake.ActualLRPGroupByProcessGuidAndIndexStub != nil {
		return fake.ActualLRPGroupByProcessGuidAndIndexStub(logger, processGuid, index)
	} else {
		return fake.actualLRPGroupByProcessGuidAndIndexReturns.result1, fake.actualLRPGroupByProcessGuidAndIndexReturns.result2
	}
}

func (fake *FakeDB) ActualLRPGroupByProcessGuidAndIndexCallCount() int {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	return len(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall)
}

func (fake *FakeDB) ActualLRPGroupByProcessGuidAndIndexArgsForCall(i int) (lager.Logger, string, int32) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	return fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i].logger, fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i].processGuid, fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i].index
}

func (fake *FakeDB) ActualLRPGroupByProcessGuidAndIndexReturns(result1 *models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupByProcessGuidAndIndexStub = nil
	fake.actualLRPGroupByProcessGuidAndIndexReturns = struct {
		result1 *models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) CreateUnclaimedActualLRP(logger lager.Logger, key *models.ActualLRPKey) error {
	fake.createUnclaimedActualLRPMutex.Lock()
	fake.createUnclaimedActualLRPArgsForCall = append(fake.createUnclaimedActualLRPArgsForCall, struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}{logger, key})
	fake.createUnclaimedActualLRPMutex.Unlock()
	if fake.CreateUnclaimedActualLRPStub != nil {
		return fake.CreateUnclaimedActualLRPStub(logger, key)
	} else {
		return fake.createUnclaimedActualLRPReturns.result1
	}
}

func (fake *FakeDB) CreateUnclaimedActualLRPCallCount() int {
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	return len(fake.createUnclaimedActualLRPArgsForCall)
}

func (fake *FakeDB) CreateUnclaimedActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	return fake.createUnclaimedActualLRPArgsForCall[i].logger, fake.createUnclaimedActualLRPArgsForCall[i].key
}

func (fake *FakeDB) CreateUnclaimedActualLRPReturns(result1 error) {
	fake.CreateUnclaimedActualLRPStub = nil
	fake.createUnclaimedActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) UnclaimActualLRP(logger lager.Logger, key *models.ActualLRPKey) error {
	fake.unclaimActualLRPMutex.Lock()
	fake.unclaimActualLRPArgsForCall = append(fake.unclaimActualLRPArgsForCall, struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}{logger, key})
	fake.unclaimActualLRPMutex.Unlock()
	if fake.UnclaimActualLRPStub != nil {
		return fake.UnclaimActualLRPStub(logger, key)
	} else {
		return fake.unclaimActualLRPReturns.result1
	}
}

func (fake *FakeDB) UnclaimActualLRPCallCount() int {
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	return len(fake.unclaimActualLRPArgsForCall)
}

func (fake *FakeDB) UnclaimActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	return fake.unclaimActualLRPArgsForCall[i].logger, fake.unclaimActualLRPArgsForCall[i].key
}

func (fake *FakeDB) UnclaimActualLRPReturns(result1 error) {
	fake.UnclaimActualLRPStub = nil
	fake.unclaimActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) ClaimActualLRP(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) error {
	fake.claimActualLRPMutex.Lock()
	fake.claimActualLRPArgsForCall = append(fake.claimActualLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}{logger, processGuid, index, instanceKey})
	fake.claimActualLRPMutex.Unlock()
	if fake.ClaimActualLRPStub != nil {
		return fake.ClaimActualLRPStub(logger, processGuid, index, instanceKey)
	} else {
		return fake.claimActualLRPReturns.result1
	}
}

func (fake *FakeDB) ClaimActualLRPCallCount() int {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return len(fake.claimActualLRPArgsForCall)
}

func (fake *FakeDB) ClaimActualLRPArgsForCall(i int) (lager.Logger, string, int32, *models.ActualLRPInstanceKey) {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return fake.claimActualLRPArgsForCall[i].logger, fake.claimActualLRPArgsForCall[i].processGuid, fake.claimActualLRPArgsForCall[i].index, fake.claimActualLRPArgsForCall[i].instanceKey
}

func (fake *FakeDB) ClaimActualLRPReturns(result1 error) {
	fake.ClaimActualLRPStub = nil
	fake.claimActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) StartActualLRP(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, netInfo *models.ActualLRPNetInfo) error {
	fake.startActualLRPMutex.Lock()
	fake.startActualLRPArgsForCall = append(fake.startActualLRPArgsForCall, struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		netInfo     *models.ActualLRPNetInfo
	}{logger, key, instanceKey, netInfo})
	fake.startActualLRPMutex.Unlock()
	if fake.StartActualLRPStub != nil {
		return fake.StartActualLRPStub(logger, key, instanceKey, netInfo)
	} else {
		return fake.startActualLRPReturns.result1
	}
}

func (fake *FakeDB) StartActualLRPCallCount() int {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return len(fake.startActualLRPArgsForCall)
}

func (fake *FakeDB) StartActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return fake.startActualLRPArgsForCall[i].logger, fake.startActualLRPArgsForCall[i].key, fake.startActualLRPArgsForCall[i].instanceKey, fake.startActualLRPArgsForCall[i].netInfo
}

func (fake *FakeDB) StartActualLRPReturns(result1 error) {
	fake.StartActualLRPStub = nil
	fake.startActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) CrashActualLRP(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, crashReason string) (shouldRestart bool, err error) {
	fake.crashActualLRPMutex.Lock()
	fake.crashActualLRPArgsForCall = append(fake.crashActualLRPArgsForCall, struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		crashReason string
	}{logger, key, instanceKey, crashReason})
	fake.crashActualLRPMutex.Unlock()
	if fake.CrashActualLRPStub != nil {
		return fake.CrashActualLRPStub(logger, key, instanceKey, crashReason)
	} else {
		return fake.crashActualLRPReturns.result1, fake.crashActualLRPReturns.result2
	}
}

func (fake *FakeDB) CrashActualLRPCallCount() int {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return len(fake.crashActualLRPArgsForCall)
}

func (fake *FakeDB) CrashActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return fake.crashActualLRPArgsForCall[i].logger, fake.crashActualLRPArgsForCall[i].key, fake.crashActualLRPArgsForCall[i].instanceKey, fake.crashActualLRPArgsForCall[i].crashReason
}

func (fake *FakeDB) CrashActualLRPReturns(result1 bool, result2 error) {
	fake.CrashActualLRPStub = nil
	fake.crashActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) FailActualLRP(logger lager.Logger, key *models.ActualLRPKey, placementError string) error {
	fake.failActualLRPMutex.Lock()
	fake.failActualLRPArgsForCall = append(fake.failActualLRPArgsForCall, struct {
		logger         lager.Logger
		key            *models.ActualLRPKey
		placementError string
	}{logger, key, placementError})
	fake.failActualLRPMutex.Unlock()
	if fake.FailActualLRPStub != nil {
		return fake.FailActualLRPStub(logger, key, placementError)
	} else {
		return fake.failActualLRPReturns.result1
	}
}

func (fake *FakeDB) FailActualLRPCallCount() int {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return len(fake.failActualLRPArgsForCall)
}

func (fake *FakeDB) FailActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, string) {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return fake.failActualLRPArgsForCall[i].logger, fake.failActualLRPArgsForCall[i].key, fake.failActualLRPArgsForCall[i].placementError
}

func (fake *FakeDB) FailActualLRPReturns(result1 error) {
	fake.FailActualLRPStub = nil
	fake.failActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) RemoveActualLRP(logger lager.Logger, processGuid string, index int32) error {
	fake.removeActualLRPMutex.Lock()
	fake.removeActualLRPArgsForCall = append(fake.removeActualLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int32
	}{logger, processGuid, index})
	fake.removeActualLRPMutex.Unlock()
	if fake.RemoveActualLRPStub != nil {
		return fake.RemoveActualLRPStub(logger, processGuid, index)
	} else {
		return fake.removeActualLRPReturns.result1
	}
}

func (fake *FakeDB) RemoveActualLRPCallCount() int {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return len(fake.removeActualLRPArgsForCall)
}

func (fake *FakeDB) RemoveActualLRPArgsForCall(i int) (lager.Logger, string, int32) {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return fake.removeActualLRPArgsForCall[i].logger, fake.removeActualLRPArgsForCall[i].processGuid, fake.removeActualLRPArgsForCall[i].index
}

func (fake *FakeDB) RemoveActualLRPReturns(result1 error) {
	fake.RemoveActualLRPStub = nil
	fake.removeActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) DesiredLRPs(logger lager.Logger, filter models.DesiredLRPFilter) ([]*models.DesiredLRP, error) {
	fake.desiredLRPsMutex.Lock()
	fake.desiredLRPsArgsForCall = append(fake.desiredLRPsArgsForCall, struct {
		logger lager.Logger
		filter models.DesiredLRPFilter
	}{logger, filter})
	fake.desiredLRPsMutex.Unlock()
	if fake.DesiredLRPsStub != nil {
		return fake.DesiredLRPsStub(logger, filter)
	} else {
		return fake.desiredLRPsReturns.result1, fake.desiredLRPsReturns.result2
	}
}

func (fake *FakeDB) DesiredLRPsCallCount() int {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	return len(fake.desiredLRPsArgsForCall)
}

func (fake *FakeDB) DesiredLRPsArgsForCall(i int) (lager.Logger, models.DesiredLRPFilter) {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	return fake.desiredLRPsArgsForCall[i].logger, fake.desiredLRPsArgsForCall[i].filter
}

func (fake *FakeDB) DesiredLRPsReturns(result1 []*models.DesiredLRP, result2 error) {
	fake.DesiredLRPsStub = nil
	fake.desiredLRPsReturns = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesiredLRPByProcessGuid(logger lager.Logger, processGuid string) (*models.DesiredLRP, error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	fake.desiredLRPByProcessGuidArgsForCall = append(fake.desiredLRPByProcessGuidArgsForCall, struct {
		logger      lager.Logger
		processGuid string
	}{logger, processGuid})
	fake.desiredLRPByProcessGuidMutex.Unlock()
	if fake.DesiredLRPByProcessGuidStub != nil {
		return fake.DesiredLRPByProcessGuidStub(logger, processGuid)
	} else {
		return fake.desiredLRPByProcessGuidReturns.result1, fake.desiredLRPByProcessGuidReturns.result2
	}
}

func (fake *FakeDB) DesiredLRPByProcessGuidCallCount() int {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	return len(fake.desiredLRPByProcessGuidArgsForCall)
}

func (fake *FakeDB) DesiredLRPByProcessGuidArgsForCall(i int) (lager.Logger, string) {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	return fake.desiredLRPByProcessGuidArgsForCall[i].logger, fake.desiredLRPByProcessGuidArgsForCall[i].processGuid
}

func (fake *FakeDB) DesiredLRPByProcessGuidReturns(result1 *models.DesiredLRP, result2 error) {
	fake.DesiredLRPByProcessGuidStub = nil
	fake.desiredLRPByProcessGuidReturns = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesiredLRPSchedulingInfos(logger lager.Logger, filter models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	fake.desiredLRPSchedulingInfosArgsForCall = append(fake.desiredLRPSchedulingInfosArgsForCall, struct {
		logger lager.Logger
		filter models.DesiredLRPFilter
	}{logger, filter})
	fake.desiredLRPSchedulingInfosMutex.Unlock()
	if fake.DesiredLRPSchedulingInfosStub != nil {
		return fake.DesiredLRPSchedulingInfosStub(logger, filter)
	} else {
		return fake.desiredLRPSchedulingInfosReturns.result1, fake.desiredLRPSchedulingInfosReturns.result2
	}
}

func (fake *FakeDB) DesiredLRPSchedulingInfosCallCount() int {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	return len(fake.desiredLRPSchedulingInfosArgsForCall)
}

func (fake *FakeDB) DesiredLRPSchedulingInfosArgsForCall(i int) (lager.Logger, models.DesiredLRPFilter) {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	return fake.desiredLRPSchedulingInfosArgsForCall[i].logger, fake.desiredLRPSchedulingInfosArgsForCall[i].filter
}

func (fake *FakeDB) DesiredLRPSchedulingInfosReturns(result1 []*models.DesiredLRPSchedulingInfo, result2 error) {
	fake.DesiredLRPSchedulingInfosStub = nil
	fake.desiredLRPSchedulingInfosReturns = struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesireLRP(logger lager.Logger, desiredLRP *models.DesiredLRP) error {
	fake.desireLRPMutex.Lock()
	fake.desireLRPArgsForCall = append(fake.desireLRPArgsForCall, struct {
		logger     lager.Logger
		desiredLRP *models.DesiredLRP
	}{logger, desiredLRP})
	fake.desireLRPMutex.Unlock()
	if fake.DesireLRPStub != nil {
		return fake.DesireLRPStub(logger, desiredLRP)
	} else {
		return fake.desireLRPReturns.result1
	}
}

func (fake *FakeDB) DesireLRPCallCount() int {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	return len(fake.desireLRPArgsForCall)
}

func (fake *FakeDB) DesireLRPArgsForCall(i int) (lager.Logger, *models.DesiredLRP) {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	return fake.desireLRPArgsForCall[i].logger, fake.desireLRPArgsForCall[i].desiredLRP
}

func (fake *FakeDB) DesireLRPReturns(result1 error) {
	fake.DesireLRPStub = nil
	fake.desireLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) UpdateDesiredLRP(logger lager.Logger, processGuid string, update *models.DesiredLRPUpdate) (previousInstanceCount int32, err error) {
	fake.updateDesiredLRPMutex.Lock()
	fake.updateDesiredLRPArgsForCall = append(fake.updateDesiredLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		update      *models.DesiredLRPUpdate
	}{logger, processGuid, update})
	fake.updateDesiredLRPMutex.Unlock()
	if fake.UpdateDesiredLRPStub != nil {
		return fake.UpdateDesiredLRPStub(logger, processGuid, update)
	} else {
		return fake.updateDesiredLRPReturns.result1, fake.updateDesiredLRPReturns.result2
	}
}

func (fake *FakeDB) UpdateDesiredLRPCallCount() int {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	return len(fake.updateDesiredLRPArgsForCall)
}

func (fake *FakeDB) UpdateDesiredLRPArgsForCall(i int) (lager.Logger, string, *models.DesiredLRPUpdate) {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	return fake.updateDesiredLRPArgsForCall[i].logger, fake.updateDesiredLRPArgsForCall[i].processGuid, fake.updateDesiredLRPArgsForCall[i].update
}

func (fake *FakeDB) UpdateDesiredLRPReturns(result1 int32, result2 error) {
	fake.UpdateDesiredLRPStub = nil
	fake.updateDesiredLRPReturns = struct {
		result1 int32
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) RemoveDesiredLRP(logger lager.Logger, processGuid string) error {
	fake.removeDesiredLRPMutex.Lock()
	fake.removeDesiredLRPArgsForCall = append(fake.removeDesiredLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
	}{logger, processGuid})
	fake.removeDesiredLRPMutex.Unlock()
	if fake.RemoveDesiredLRPStub != nil {
		return fake.RemoveDesiredLRPStub(logger, processGuid)
	} else {
		return fake.removeDesiredLRPReturns.result1
	}
}

func (fake *FakeDB) RemoveDesiredLRPCallCount() int {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	return len(fake.removeDesiredLRPArgsForCall)
}

func (fake *FakeDB) RemoveDesiredLRPArgsForCall(i int) (lager.Logger, string) {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	return fake.removeDesiredLRPArgsForCall[i].logger, fake.removeDesiredLRPArgsForCall[i].processGuid
}

func (fake *FakeDB) RemoveDesiredLRPReturns(result1 error) {
	fake.RemoveDesiredLRPStub = nil
	fake.removeDesiredLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) ConvergeLRPs(logger lager.Logger) (keysToAuction []*auctioneer.LRPStartRequest, keysToRetire []*models.ActualLRPKey) {
	fake.convergeLRPsMutex.Lock()
	fake.convergeLRPsArgsForCall = append(fake.convergeLRPsArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.convergeLRPsMutex.Unlock()
	if fake.ConvergeLRPsStub != nil {
		return fake.ConvergeLRPsStub(logger)
	} else {
		return fake.convergeLRPsReturns.result1, fake.convergeLRPsReturns.result2
	}
}

func (fake *FakeDB) ConvergeLRPsCallCount() int {
	fake.convergeLRPsMutex.RLock()
	defer fake.convergeLRPsMutex.RUnlock()
	return len(fake.convergeLRPsArgsForCall)
}

func (fake *FakeDB) ConvergeLRPsArgsForCall(i int) lager.Logger {
	fake.convergeLRPsMutex.RLock()
	defer fake.convergeLRPsMutex.RUnlock()
	return fake.convergeLRPsArgsForCall[i].logger
}

func (fake *FakeDB) ConvergeLRPsReturns(result1 []*auctioneer.LRPStartRequest, result2 []*models.ActualLRPKey) {
	fake.ConvergeLRPsStub = nil
	fake.convergeLRPsReturns = struct {
		result1 []*auctioneer.LRPStartRequest
		result2 []*models.ActualLRPKey
	}{result1, result2}
}

func (fake *FakeDB) GatherAndPruneLRPs(logger lager.Logger) (*models.ConvergenceInput, error) {
	fake.gatherAndPruneLRPsMutex.Lock()
	fake.gatherAndPruneLRPsArgsForCall = append(fake.gatherAndPruneLRPsArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.gatherAndPruneLRPsMutex.Unlock()
	if fake.GatherAndPruneLRPsStub != nil {
		return fake.GatherAndPruneLRPsStub(logger)
	} else {
		return fake.gatherAndPruneLRPsReturns.result1, fake.gatherAndPruneLRPsReturns.result2
	}
}

func (fake *FakeDB) GatherAndPruneLRPsCallCount() int {
	fake.gatherAndPruneLRPsMutex.RLock()
	defer fake.gatherAndPruneLRPsMutex.RUnlock()
	return len(fake.gatherAndPruneLRPsArgsForCall)
}

func (fake *FakeDB) GatherAndPruneLRPsArgsForCall(i int) lager.Logger {
	fake.gatherAndPruneLRPsMutex.RLock()
	defer fake.gatherAndPruneLRPsMutex.RUnlock()
	return fake.gatherAndPruneLRPsArgsForCall[i].logger
}

func (fake *FakeDB) GatherAndPruneLRPsReturns(result1 *models.ConvergenceInput, result2 error) {
	fake.GatherAndPruneLRPsStub = nil
	fake.gatherAndPruneLRPsReturns = struct {
		result1 *models.ConvergenceInput
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) Tasks(logger lager.Logger, filter models.TaskFilter) ([]*models.Task, error) {
	fake.tasksMutex.Lock()
	fake.tasksArgsForCall = append(fake.tasksArgsForCall, struct {
		logger lager.Logger
		filter models.TaskFilter
	}{logger, filter})
	fake.tasksMutex.Unlock()
	if fake.TasksStub != nil {
		return fake.TasksStub(logger, filter)
	} else {
		return fake.tasksReturns.result1, fake.tasksReturns.result2
	}
}

func (fake *FakeDB) TasksCallCount() int {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return len(fake.tasksArgsForCall)
}

func (fake *FakeDB) TasksArgsForCall(i int) (lager.Logger, models.TaskFilter) {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return fake.tasksArgsForCall[i].logger, fake.tasksArgsForCall[i].filter
}

func (fake *FakeDB) TasksReturns(result1 []*models.Task, result2 error) {
	fake.TasksStub = nil
	fake.tasksReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) TaskByGuid(logger lager.Logger, taskGuid string) (*models.Task, error) {
	fake.taskByGuidMutex.Lock()
	fake.taskByGuidArgsForCall = append(fake.taskByGuidArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.taskByGuidMutex.Unlock()
	if fake.TaskByGuidStub != nil {
		return fake.TaskByGuidStub(logger, taskGuid)
	} else {
		return fake.taskByGuidReturns.result1, fake.taskByGuidReturns.result2
	}
}

func (fake *FakeDB) TaskByGuidCallCount() int {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return len(fake.taskByGuidArgsForCall)
}

func (fake *FakeDB) TaskByGuidArgsForCall(i int) (lager.Logger, string) {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return fake.taskByGuidArgsForCall[i].logger, fake.taskByGuidArgsForCall[i].taskGuid
}

func (fake *FakeDB) TaskByGuidReturns(result1 *models.Task, result2 error) {
	fake.TaskByGuidStub = nil
	fake.taskByGuidReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesireTask(logger lager.Logger, taskDefinition *models.TaskDefinition, taskGuid string, domain string) error {
	fake.desireTaskMutex.Lock()
	fake.desireTaskArgsForCall = append(fake.desireTaskArgsForCall, struct {
		logger         lager.Logger
		taskDefinition *models.TaskDefinition
		taskGuid       string
		domain         string
	}{logger, taskDefinition, taskGuid, domain})
	fake.desireTaskMutex.Unlock()
	if fake.DesireTaskStub != nil {
		return fake.DesireTaskStub(logger, taskDefinition, taskGuid, domain)
	} else {
		return fake.desireTaskReturns.result1
	}
}

func (fake *FakeDB) DesireTaskCallCount() int {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return len(fake.desireTaskArgsForCall)
}

func (fake *FakeDB) DesireTaskArgsForCall(i int) (lager.Logger, *models.TaskDefinition, string, string) {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return fake.desireTaskArgsForCall[i].logger, fake.desireTaskArgsForCall[i].taskDefinition, fake.desireTaskArgsForCall[i].taskGuid, fake.desireTaskArgsForCall[i].domain
}

func (fake *FakeDB) DesireTaskReturns(result1 error) {
	fake.DesireTaskStub = nil
	fake.desireTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) StartTask(logger lager.Logger, taskGuid string, cellId string) (bool, error) {
	fake.startTaskMutex.Lock()
	fake.startTaskArgsForCall = append(fake.startTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
		cellId   string
	}{logger, taskGuid, cellId})
	fake.startTaskMutex.Unlock()
	if fake.StartTaskStub != nil {
		return fake.StartTaskStub(logger, taskGuid, cellId)
	} else {
		return fake.startTaskReturns.result1, fake.startTaskReturns.result2
	}
}

func (fake *FakeDB) StartTaskCallCount() int {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return len(fake.startTaskArgsForCall)
}

func (fake *FakeDB) StartTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return fake.startTaskArgsForCall[i].logger, fake.startTaskArgsForCall[i].taskGuid, fake.startTaskArgsForCall[i].cellId
}

func (fake *FakeDB) StartTaskReturns(result1 bool, result2 error) {
	fake.StartTaskStub = nil
	fake.startTaskReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) CancelTask(logger lager.Logger, taskGuid string) (task *models.Task, err error) {
	fake.cancelTaskMutex.Lock()
	fake.cancelTaskArgsForCall = append(fake.cancelTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.cancelTaskMutex.Unlock()
	if fake.CancelTaskStub != nil {
		return fake.CancelTaskStub(logger, taskGuid)
	} else {
		return fake.cancelTaskReturns.result1, fake.cancelTaskReturns.result2
	}
}

func (fake *FakeDB) CancelTaskCallCount() int {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return len(fake.cancelTaskArgsForCall)
}

func (fake *FakeDB) CancelTaskArgsForCall(i int) (lager.Logger, string) {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return fake.cancelTaskArgsForCall[i].logger, fake.cancelTaskArgsForCall[i].taskGuid
}

func (fake *FakeDB) CancelTaskReturns(result1 *models.Task, result2 error) {
	fake.CancelTaskStub = nil
	fake.cancelTaskReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) FailTask(logger lager.Logger, taskGuid string, failureReason string) (task *models.Task, err error) {
	fake.failTaskMutex.Lock()
	fake.failTaskArgsForCall = append(fake.failTaskArgsForCall, struct {
		logger        lager.Logger
		taskGuid      string
		failureReason string
	}{logger, taskGuid, failureReason})
	fake.failTaskMutex.Unlock()
	if fake.FailTaskStub != nil {
		return fake.FailTaskStub(logger, taskGuid, failureReason)
	} else {
		return fake.failTaskReturns.result1, fake.failTaskReturns.result2
	}
}

func (fake *FakeDB) FailTaskCallCount() int {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return len(fake.failTaskArgsForCall)
}

func (fake *FakeDB) FailTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return fake.failTaskArgsForCall[i].logger, fake.failTaskArgsForCall[i].taskGuid, fake.failTaskArgsForCall[i].failureReason
}

func (fake *FakeDB) FailTaskReturns(result1 *models.Task, result2 error) {
	fake.FailTaskStub = nil
	fake.failTaskReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) CompleteTask(logger lager.Logger, taskGuid string, cellId string, failed bool, failureReason string, result string) (task *models.Task, err error) {
	fake.completeTaskMutex.Lock()
	fake.completeTaskArgsForCall = append(fake.completeTaskArgsForCall, struct {
		logger        lager.Logger
		taskGuid      string
		cellId        string
		failed        bool
		failureReason string
		result        string
	}{logger, taskGuid, cellId, failed, failureReason, result})
	fake.completeTaskMutex.Unlock()
	if fake.CompleteTaskStub != nil {
		return fake.CompleteTaskStub(logger, taskGuid, cellId, failed, failureReason, result)
	} else {
		return fake.completeTaskReturns.result1, fake.completeTaskReturns.result2
	}
}

func (fake *FakeDB) CompleteTaskCallCount() int {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return len(fake.completeTaskArgsForCall)
}

func (fake *FakeDB) CompleteTaskArgsForCall(i int) (lager.Logger, string, string, bool, string, string) {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return fake.completeTaskArgsForCall[i].logger, fake.completeTaskArgsForCall[i].taskGuid, fake.completeTaskArgsForCall[i].cellId, fake.completeTaskArgsForCall[i].failed, fake.completeTaskArgsForCall[i].failureReason, fake.completeTaskArgsForCall[i].result
}

func (fake *FakeDB) CompleteTaskReturns(result1 *models.Task, result2 error) {
	fake.CompleteTaskStub = nil
	fake.completeTaskReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ResolvingTask(logger lager.Logger, taskGuid string) error {
	fake.resolvingTaskMutex.Lock()
	fake.resolvingTaskArgsForCall = append(fake.resolvingTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.resolvingTaskMutex.Unlock()
	if fake.ResolvingTaskStub != nil {
		return fake.ResolvingTaskStub(logger, taskGuid)
	} else {
		return fake.resolvingTaskReturns.result1
	}
}

func (fake *FakeDB) ResolvingTaskCallCount() int {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return len(fake.resolvingTaskArgsForCall)
}

func (fake *FakeDB) ResolvingTaskArgsForCall(i int) (lager.Logger, string) {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return fake.resolvingTaskArgsForCall[i].logger, fake.resolvingTaskArgsForCall[i].taskGuid
}

func (fake *FakeDB) ResolvingTaskReturns(result1 error) {
	fake.ResolvingTaskStub = nil
	fake.resolvingTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) DeleteTask(logger lager.Logger, taskGuid string) error {
	fake.deleteTaskMutex.Lock()
	fake.deleteTaskArgsForCall = append(fake.deleteTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.deleteTaskMutex.Unlock()
	if fake.DeleteTaskStub != nil {
		return fake.DeleteTaskStub(logger, taskGuid)
	} else {
		return fake.deleteTaskReturns.result1
	}
}

func (fake *FakeDB) DeleteTaskCallCount() int {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return len(fake.deleteTaskArgsForCall)
}

func (fake *FakeDB) DeleteTaskArgsForCall(i int) (lager.Logger, string) {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return fake.deleteTaskArgsForCall[i].logger, fake.deleteTaskArgsForCall[i].taskGuid
}

func (fake *FakeDB) DeleteTaskReturns(result1 error) {
	fake.DeleteTaskStub = nil
	fake.deleteTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) ConvergeTasks(logger lager.Logger, kickTaskDuration time.Duration, expirePendingTaskDuration time.Duration, expireCompletedTaskDuration time.Duration) {
	fake.convergeTasksMutex.Lock()
	fake.convergeTasksArgsForCall = append(fake.convergeTasksArgsForCall, struct {
		logger                      lager.Logger
		kickTaskDuration            time.Duration
		expirePendingTaskDuration   time.Duration
		expireCompletedTaskDuration time.Duration
	}{logger, kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration})
	fake.convergeTasksMutex.Unlock()
	if fake.ConvergeTasksStub != nil {
		fake.ConvergeTasksStub(logger, kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration)
	}
}

func (fake *FakeDB) ConvergeTasksCallCount() int {
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	return len(fake.convergeTasksArgsForCall)
}

func (fake *FakeDB) ConvergeTasksArgsForCall(i int) (lager.Logger, time.Duration, time.Duration, time.Duration) {
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	return fake.convergeTasksArgsForCall[i].logger, fake.convergeTasksArgsForCall[i].kickTaskDuration, fake.convergeTasksArgsForCall[i].expirePendingTaskDuration, fake.convergeTasksArgsForCall[i].expireCompletedTaskDuration
}

func (fake *FakeDB) Version(logger lager.Logger) (*models.Version, error) {
	fake.versionMutex.Lock()
	fake.versionArgsForCall = append(fake.versionArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.versionMutex.Unlock()
	if fake.VersionStub != nil {
		return fake.VersionStub(logger)
	} else {
		return fake.versionReturns.result1, fake.versionReturns.result2
	}
}

func (fake *FakeDB) VersionCallCount() int {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return len(fake.versionArgsForCall)
}

func (fake *FakeDB) VersionArgsForCall(i int) lager.Logger {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return fake.versionArgsForCall[i].logger
}

func (fake *FakeDB) VersionReturns(result1 *models.Version, result2 error) {
	fake.VersionStub = nil
	fake.versionReturns = struct {
		result1 *models.Version
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) SetVersion(logger lager.Logger, version *models.Version) error {
	fake.setVersionMutex.Lock()
	fake.setVersionArgsForCall = append(fake.setVersionArgsForCall, struct {
		logger  lager.Logger
		version *models.Version
	}{logger, version})
	fake.setVersionMutex.Unlock()
	if fake.SetVersionStub != nil {
		return fake.SetVersionStub(logger, version)
	} else {
		return fake.setVersionReturns.result1
	}
}

func (fake *FakeDB) SetVersionCallCount() int {
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	return len(fake.setVersionArgsForCall)
}

func (fake *FakeDB) SetVersionArgsForCall(i int) (lager.Logger, *models.Version) {
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	return fake.setVersionArgsForCall[i].logger, fake.setVersionArgsForCall[i].version
}

func (fake *FakeDB) SetVersionReturns(result1 error) {
	fake.SetVersionStub = nil
	fake.setVersionReturns = struct {
		result1 error
	}{result1}
}

var _ db.DB = new(FakeDB)
