// Code generated by counterfeiter. DO NOT EDIT.
package helpersfakes

import (
	"database/sql"
	"sync"

	"code.cloudfoundry.org/bbs/db/sqldb/helpers"
	"code.cloudfoundry.org/lager"
)

type FakeSQLHelper struct {
	TransactStub        func(logger lager.Logger, db helpers.QueryableDB, f func(logger lager.Logger, tx helpers.Tx) error) error
	transactMutex       sync.RWMutex
	transactArgsForCall []struct {
		logger lager.Logger
		db     helpers.QueryableDB
		f      func(logger lager.Logger, tx helpers.Tx) error
	}
	transactReturns struct {
		result1 error
	}
	transactReturnsOnCall map[int]struct {
		result1 error
	}
	OneStub        func(logger lager.Logger, q helpers.Queryable, table string, columns helpers.ColumnList, lockRow helpers.RowLock, wheres string, whereBindings ...interface{}) helpers.RowScanner
	oneMutex       sync.RWMutex
	oneArgsForCall []struct {
		logger        lager.Logger
		q             helpers.Queryable
		table         string
		columns       helpers.ColumnList
		lockRow       helpers.RowLock
		wheres        string
		whereBindings []interface{}
	}
	oneReturns struct {
		result1 helpers.RowScanner
	}
	oneReturnsOnCall map[int]struct {
		result1 helpers.RowScanner
	}
	AllStub        func(logger lager.Logger, q helpers.Queryable, table string, columns helpers.ColumnList, lockRow helpers.RowLock, wheres string, whereBindings ...interface{}) (*sql.Rows, error)
	allMutex       sync.RWMutex
	allArgsForCall []struct {
		logger        lager.Logger
		q             helpers.Queryable
		table         string
		columns       helpers.ColumnList
		lockRow       helpers.RowLock
		wheres        string
		whereBindings []interface{}
	}
	allReturns struct {
		result1 *sql.Rows
		result2 error
	}
	allReturnsOnCall map[int]struct {
		result1 *sql.Rows
		result2 error
	}
	UpsertStub        func(logger lager.Logger, q helpers.Queryable, table string, attributes helpers.SQLAttributes, wheres string, whereBindings ...interface{}) (sql.Result, error)
	upsertMutex       sync.RWMutex
	upsertArgsForCall []struct {
		logger        lager.Logger
		q             helpers.Queryable
		table         string
		attributes    helpers.SQLAttributes
		wheres        string
		whereBindings []interface{}
	}
	upsertReturns struct {
		result1 sql.Result
		result2 error
	}
	upsertReturnsOnCall map[int]struct {
		result1 sql.Result
		result2 error
	}
	InsertStub        func(logger lager.Logger, q helpers.Queryable, table string, attributes helpers.SQLAttributes) (sql.Result, error)
	insertMutex       sync.RWMutex
	insertArgsForCall []struct {
		logger     lager.Logger
		q          helpers.Queryable
		table      string
		attributes helpers.SQLAttributes
	}
	insertReturns struct {
		result1 sql.Result
		result2 error
	}
	insertReturnsOnCall map[int]struct {
		result1 sql.Result
		result2 error
	}
	UpdateStub        func(logger lager.Logger, q helpers.Queryable, table string, updates helpers.SQLAttributes, wheres string, whereBindings ...interface{}) (sql.Result, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		logger        lager.Logger
		q             helpers.Queryable
		table         string
		updates       helpers.SQLAttributes
		wheres        string
		whereBindings []interface{}
	}
	updateReturns struct {
		result1 sql.Result
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 sql.Result
		result2 error
	}
	DeleteStub        func(logger lager.Logger, q helpers.Queryable, table string, wheres string, whereBindings ...interface{}) (sql.Result, error)
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		logger        lager.Logger
		q             helpers.Queryable
		table         string
		wheres        string
		whereBindings []interface{}
	}
	deleteReturns struct {
		result1 sql.Result
		result2 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 sql.Result
		result2 error
	}
	CountStub        func(logger lager.Logger, q helpers.Queryable, table string, wheres string, whereBindings ...interface{}) (int, error)
	countMutex       sync.RWMutex
	countArgsForCall []struct {
		logger        lager.Logger
		q             helpers.Queryable
		table         string
		wheres        string
		whereBindings []interface{}
	}
	countReturns struct {
		result1 int
		result2 error
	}
	countReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	ConvertSQLErrorStub        func(err error) error
	convertSQLErrorMutex       sync.RWMutex
	convertSQLErrorArgsForCall []struct {
		err error
	}
	convertSQLErrorReturns struct {
		result1 error
	}
	convertSQLErrorReturnsOnCall map[int]struct {
		result1 error
	}
	RebindStub        func(query string) string
	rebindMutex       sync.RWMutex
	rebindArgsForCall []struct {
		query string
	}
	rebindReturns struct {
		result1 string
	}
	rebindReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSQLHelper) Transact(logger lager.Logger, db helpers.QueryableDB, f func(logger lager.Logger, tx helpers.Tx) error) error {
	fake.transactMutex.Lock()
	ret, specificReturn := fake.transactReturnsOnCall[len(fake.transactArgsForCall)]
	fake.transactArgsForCall = append(fake.transactArgsForCall, struct {
		logger lager.Logger
		db     helpers.QueryableDB
		f      func(logger lager.Logger, tx helpers.Tx) error
	}{logger, db, f})
	fake.recordInvocation("Transact", []interface{}{logger, db, f})
	fake.transactMutex.Unlock()
	if fake.TransactStub != nil {
		return fake.TransactStub(logger, db, f)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.transactReturns.result1
}

func (fake *FakeSQLHelper) TransactCallCount() int {
	fake.transactMutex.RLock()
	defer fake.transactMutex.RUnlock()
	return len(fake.transactArgsForCall)
}

func (fake *FakeSQLHelper) TransactArgsForCall(i int) (lager.Logger, helpers.QueryableDB, func(logger lager.Logger, tx helpers.Tx) error) {
	fake.transactMutex.RLock()
	defer fake.transactMutex.RUnlock()
	return fake.transactArgsForCall[i].logger, fake.transactArgsForCall[i].db, fake.transactArgsForCall[i].f
}

func (fake *FakeSQLHelper) TransactReturns(result1 error) {
	fake.TransactStub = nil
	fake.transactReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSQLHelper) TransactReturnsOnCall(i int, result1 error) {
	fake.TransactStub = nil
	if fake.transactReturnsOnCall == nil {
		fake.transactReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.transactReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSQLHelper) One(logger lager.Logger, q helpers.Queryable, table string, columns helpers.ColumnList, lockRow helpers.RowLock, wheres string, whereBindings ...interface{}) helpers.RowScanner {
	fake.oneMutex.Lock()
	ret, specificReturn := fake.oneReturnsOnCall[len(fake.oneArgsForCall)]
	fake.oneArgsForCall = append(fake.oneArgsForCall, struct {
		logger        lager.Logger
		q             helpers.Queryable
		table         string
		columns       helpers.ColumnList
		lockRow       helpers.RowLock
		wheres        string
		whereBindings []interface{}
	}{logger, q, table, columns, lockRow, wheres, whereBindings})
	fake.recordInvocation("One", []interface{}{logger, q, table, columns, lockRow, wheres, whereBindings})
	fake.oneMutex.Unlock()
	if fake.OneStub != nil {
		return fake.OneStub(logger, q, table, columns, lockRow, wheres, whereBindings...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.oneReturns.result1
}

func (fake *FakeSQLHelper) OneCallCount() int {
	fake.oneMutex.RLock()
	defer fake.oneMutex.RUnlock()
	return len(fake.oneArgsForCall)
}

func (fake *FakeSQLHelper) OneArgsForCall(i int) (lager.Logger, helpers.Queryable, string, helpers.ColumnList, helpers.RowLock, string, []interface{}) {
	fake.oneMutex.RLock()
	defer fake.oneMutex.RUnlock()
	return fake.oneArgsForCall[i].logger, fake.oneArgsForCall[i].q, fake.oneArgsForCall[i].table, fake.oneArgsForCall[i].columns, fake.oneArgsForCall[i].lockRow, fake.oneArgsForCall[i].wheres, fake.oneArgsForCall[i].whereBindings
}

func (fake *FakeSQLHelper) OneReturns(result1 helpers.RowScanner) {
	fake.OneStub = nil
	fake.oneReturns = struct {
		result1 helpers.RowScanner
	}{result1}
}

func (fake *FakeSQLHelper) OneReturnsOnCall(i int, result1 helpers.RowScanner) {
	fake.OneStub = nil
	if fake.oneReturnsOnCall == nil {
		fake.oneReturnsOnCall = make(map[int]struct {
			result1 helpers.RowScanner
		})
	}
	fake.oneReturnsOnCall[i] = struct {
		result1 helpers.RowScanner
	}{result1}
}

func (fake *FakeSQLHelper) All(logger lager.Logger, q helpers.Queryable, table string, columns helpers.ColumnList, lockRow helpers.RowLock, wheres string, whereBindings ...interface{}) (*sql.Rows, error) {
	fake.allMutex.Lock()
	ret, specificReturn := fake.allReturnsOnCall[len(fake.allArgsForCall)]
	fake.allArgsForCall = append(fake.allArgsForCall, struct {
		logger        lager.Logger
		q             helpers.Queryable
		table         string
		columns       helpers.ColumnList
		lockRow       helpers.RowLock
		wheres        string
		whereBindings []interface{}
	}{logger, q, table, columns, lockRow, wheres, whereBindings})
	fake.recordInvocation("All", []interface{}{logger, q, table, columns, lockRow, wheres, whereBindings})
	fake.allMutex.Unlock()
	if fake.AllStub != nil {
		return fake.AllStub(logger, q, table, columns, lockRow, wheres, whereBindings...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.allReturns.result1, fake.allReturns.result2
}

func (fake *FakeSQLHelper) AllCallCount() int {
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	return len(fake.allArgsForCall)
}

func (fake *FakeSQLHelper) AllArgsForCall(i int) (lager.Logger, helpers.Queryable, string, helpers.ColumnList, helpers.RowLock, string, []interface{}) {
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	return fake.allArgsForCall[i].logger, fake.allArgsForCall[i].q, fake.allArgsForCall[i].table, fake.allArgsForCall[i].columns, fake.allArgsForCall[i].lockRow, fake.allArgsForCall[i].wheres, fake.allArgsForCall[i].whereBindings
}

func (fake *FakeSQLHelper) AllReturns(result1 *sql.Rows, result2 error) {
	fake.AllStub = nil
	fake.allReturns = struct {
		result1 *sql.Rows
		result2 error
	}{result1, result2}
}

func (fake *FakeSQLHelper) AllReturnsOnCall(i int, result1 *sql.Rows, result2 error) {
	fake.AllStub = nil
	if fake.allReturnsOnCall == nil {
		fake.allReturnsOnCall = make(map[int]struct {
			result1 *sql.Rows
			result2 error
		})
	}
	fake.allReturnsOnCall[i] = struct {
		result1 *sql.Rows
		result2 error
	}{result1, result2}
}

func (fake *FakeSQLHelper) Upsert(logger lager.Logger, q helpers.Queryable, table string, attributes helpers.SQLAttributes, wheres string, whereBindings ...interface{}) (sql.Result, error) {
	fake.upsertMutex.Lock()
	ret, specificReturn := fake.upsertReturnsOnCall[len(fake.upsertArgsForCall)]
	fake.upsertArgsForCall = append(fake.upsertArgsForCall, struct {
		logger        lager.Logger
		q             helpers.Queryable
		table         string
		attributes    helpers.SQLAttributes
		wheres        string
		whereBindings []interface{}
	}{logger, q, table, attributes, wheres, whereBindings})
	fake.recordInvocation("Upsert", []interface{}{logger, q, table, attributes, wheres, whereBindings})
	fake.upsertMutex.Unlock()
	if fake.UpsertStub != nil {
		return fake.UpsertStub(logger, q, table, attributes, wheres, whereBindings...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.upsertReturns.result1, fake.upsertReturns.result2
}

func (fake *FakeSQLHelper) UpsertCallCount() int {
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	return len(fake.upsertArgsForCall)
}

func (fake *FakeSQLHelper) UpsertArgsForCall(i int) (lager.Logger, helpers.Queryable, string, helpers.SQLAttributes, string, []interface{}) {
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	return fake.upsertArgsForCall[i].logger, fake.upsertArgsForCall[i].q, fake.upsertArgsForCall[i].table, fake.upsertArgsForCall[i].attributes, fake.upsertArgsForCall[i].wheres, fake.upsertArgsForCall[i].whereBindings
}

func (fake *FakeSQLHelper) UpsertReturns(result1 sql.Result, result2 error) {
	fake.UpsertStub = nil
	fake.upsertReturns = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *FakeSQLHelper) UpsertReturnsOnCall(i int, result1 sql.Result, result2 error) {
	fake.UpsertStub = nil
	if fake.upsertReturnsOnCall == nil {
		fake.upsertReturnsOnCall = make(map[int]struct {
			result1 sql.Result
			result2 error
		})
	}
	fake.upsertReturnsOnCall[i] = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *FakeSQLHelper) Insert(logger lager.Logger, q helpers.Queryable, table string, attributes helpers.SQLAttributes) (sql.Result, error) {
	fake.insertMutex.Lock()
	ret, specificReturn := fake.insertReturnsOnCall[len(fake.insertArgsForCall)]
	fake.insertArgsForCall = append(fake.insertArgsForCall, struct {
		logger     lager.Logger
		q          helpers.Queryable
		table      string
		attributes helpers.SQLAttributes
	}{logger, q, table, attributes})
	fake.recordInvocation("Insert", []interface{}{logger, q, table, attributes})
	fake.insertMutex.Unlock()
	if fake.InsertStub != nil {
		return fake.InsertStub(logger, q, table, attributes)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.insertReturns.result1, fake.insertReturns.result2
}

func (fake *FakeSQLHelper) InsertCallCount() int {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	return len(fake.insertArgsForCall)
}

func (fake *FakeSQLHelper) InsertArgsForCall(i int) (lager.Logger, helpers.Queryable, string, helpers.SQLAttributes) {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	return fake.insertArgsForCall[i].logger, fake.insertArgsForCall[i].q, fake.insertArgsForCall[i].table, fake.insertArgsForCall[i].attributes
}

func (fake *FakeSQLHelper) InsertReturns(result1 sql.Result, result2 error) {
	fake.InsertStub = nil
	fake.insertReturns = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *FakeSQLHelper) InsertReturnsOnCall(i int, result1 sql.Result, result2 error) {
	fake.InsertStub = nil
	if fake.insertReturnsOnCall == nil {
		fake.insertReturnsOnCall = make(map[int]struct {
			result1 sql.Result
			result2 error
		})
	}
	fake.insertReturnsOnCall[i] = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *FakeSQLHelper) Update(logger lager.Logger, q helpers.Queryable, table string, updates helpers.SQLAttributes, wheres string, whereBindings ...interface{}) (sql.Result, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		logger        lager.Logger
		q             helpers.Queryable
		table         string
		updates       helpers.SQLAttributes
		wheres        string
		whereBindings []interface{}
	}{logger, q, table, updates, wheres, whereBindings})
	fake.recordInvocation("Update", []interface{}{logger, q, table, updates, wheres, whereBindings})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(logger, q, table, updates, wheres, whereBindings...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateReturns.result1, fake.updateReturns.result2
}

func (fake *FakeSQLHelper) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeSQLHelper) UpdateArgsForCall(i int) (lager.Logger, helpers.Queryable, string, helpers.SQLAttributes, string, []interface{}) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].logger, fake.updateArgsForCall[i].q, fake.updateArgsForCall[i].table, fake.updateArgsForCall[i].updates, fake.updateArgsForCall[i].wheres, fake.updateArgsForCall[i].whereBindings
}

func (fake *FakeSQLHelper) UpdateReturns(result1 sql.Result, result2 error) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *FakeSQLHelper) UpdateReturnsOnCall(i int, result1 sql.Result, result2 error) {
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 sql.Result
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *FakeSQLHelper) Delete(logger lager.Logger, q helpers.Queryable, table string, wheres string, whereBindings ...interface{}) (sql.Result, error) {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		logger        lager.Logger
		q             helpers.Queryable
		table         string
		wheres        string
		whereBindings []interface{}
	}{logger, q, table, wheres, whereBindings})
	fake.recordInvocation("Delete", []interface{}{logger, q, table, wheres, whereBindings})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(logger, q, table, wheres, whereBindings...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deleteReturns.result1, fake.deleteReturns.result2
}

func (fake *FakeSQLHelper) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeSQLHelper) DeleteArgsForCall(i int) (lager.Logger, helpers.Queryable, string, string, []interface{}) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].logger, fake.deleteArgsForCall[i].q, fake.deleteArgsForCall[i].table, fake.deleteArgsForCall[i].wheres, fake.deleteArgsForCall[i].whereBindings
}

func (fake *FakeSQLHelper) DeleteReturns(result1 sql.Result, result2 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *FakeSQLHelper) DeleteReturnsOnCall(i int, result1 sql.Result, result2 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 sql.Result
			result2 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *FakeSQLHelper) Count(logger lager.Logger, q helpers.Queryable, table string, wheres string, whereBindings ...interface{}) (int, error) {
	fake.countMutex.Lock()
	ret, specificReturn := fake.countReturnsOnCall[len(fake.countArgsForCall)]
	fake.countArgsForCall = append(fake.countArgsForCall, struct {
		logger        lager.Logger
		q             helpers.Queryable
		table         string
		wheres        string
		whereBindings []interface{}
	}{logger, q, table, wheres, whereBindings})
	fake.recordInvocation("Count", []interface{}{logger, q, table, wheres, whereBindings})
	fake.countMutex.Unlock()
	if fake.CountStub != nil {
		return fake.CountStub(logger, q, table, wheres, whereBindings...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.countReturns.result1, fake.countReturns.result2
}

func (fake *FakeSQLHelper) CountCallCount() int {
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	return len(fake.countArgsForCall)
}

func (fake *FakeSQLHelper) CountArgsForCall(i int) (lager.Logger, helpers.Queryable, string, string, []interface{}) {
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	return fake.countArgsForCall[i].logger, fake.countArgsForCall[i].q, fake.countArgsForCall[i].table, fake.countArgsForCall[i].wheres, fake.countArgsForCall[i].whereBindings
}

func (fake *FakeSQLHelper) CountReturns(result1 int, result2 error) {
	fake.CountStub = nil
	fake.countReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSQLHelper) CountReturnsOnCall(i int, result1 int, result2 error) {
	fake.CountStub = nil
	if fake.countReturnsOnCall == nil {
		fake.countReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.countReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSQLHelper) ConvertSQLError(err error) error {
	fake.convertSQLErrorMutex.Lock()
	ret, specificReturn := fake.convertSQLErrorReturnsOnCall[len(fake.convertSQLErrorArgsForCall)]
	fake.convertSQLErrorArgsForCall = append(fake.convertSQLErrorArgsForCall, struct {
		err error
	}{err})
	fake.recordInvocation("ConvertSQLError", []interface{}{err})
	fake.convertSQLErrorMutex.Unlock()
	if fake.ConvertSQLErrorStub != nil {
		return fake.ConvertSQLErrorStub(err)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.convertSQLErrorReturns.result1
}

func (fake *FakeSQLHelper) ConvertSQLErrorCallCount() int {
	fake.convertSQLErrorMutex.RLock()
	defer fake.convertSQLErrorMutex.RUnlock()
	return len(fake.convertSQLErrorArgsForCall)
}

func (fake *FakeSQLHelper) ConvertSQLErrorArgsForCall(i int) error {
	fake.convertSQLErrorMutex.RLock()
	defer fake.convertSQLErrorMutex.RUnlock()
	return fake.convertSQLErrorArgsForCall[i].err
}

func (fake *FakeSQLHelper) ConvertSQLErrorReturns(result1 error) {
	fake.ConvertSQLErrorStub = nil
	fake.convertSQLErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSQLHelper) ConvertSQLErrorReturnsOnCall(i int, result1 error) {
	fake.ConvertSQLErrorStub = nil
	if fake.convertSQLErrorReturnsOnCall == nil {
		fake.convertSQLErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.convertSQLErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSQLHelper) Rebind(query string) string {
	fake.rebindMutex.Lock()
	ret, specificReturn := fake.rebindReturnsOnCall[len(fake.rebindArgsForCall)]
	fake.rebindArgsForCall = append(fake.rebindArgsForCall, struct {
		query string
	}{query})
	fake.recordInvocation("Rebind", []interface{}{query})
	fake.rebindMutex.Unlock()
	if fake.RebindStub != nil {
		return fake.RebindStub(query)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rebindReturns.result1
}

func (fake *FakeSQLHelper) RebindCallCount() int {
	fake.rebindMutex.RLock()
	defer fake.rebindMutex.RUnlock()
	return len(fake.rebindArgsForCall)
}

func (fake *FakeSQLHelper) RebindArgsForCall(i int) string {
	fake.rebindMutex.RLock()
	defer fake.rebindMutex.RUnlock()
	return fake.rebindArgsForCall[i].query
}

func (fake *FakeSQLHelper) RebindReturns(result1 string) {
	fake.RebindStub = nil
	fake.rebindReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeSQLHelper) RebindReturnsOnCall(i int, result1 string) {
	fake.RebindStub = nil
	if fake.rebindReturnsOnCall == nil {
		fake.rebindReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.rebindReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeSQLHelper) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.transactMutex.RLock()
	defer fake.transactMutex.RUnlock()
	fake.oneMutex.RLock()
	defer fake.oneMutex.RUnlock()
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	fake.convertSQLErrorMutex.RLock()
	defer fake.convertSQLErrorMutex.RUnlock()
	fake.rebindMutex.RLock()
	defer fake.rebindMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSQLHelper) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ helpers.SQLHelper = new(FakeSQLHelper)
