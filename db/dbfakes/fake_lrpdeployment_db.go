// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"

	"code.cloudfoundry.org/bbs/db"
	"code.cloudfoundry.org/bbs/models"
	"code.cloudfoundry.org/lager"
)

type FakeLRPDeploymentDB struct {
	CreateLRPDeploymentStub        func(logger lager.Logger, lrp *models.LRPDeploymentCreation) (*models.LRPDeployment, error)
	createLRPDeploymentMutex       sync.RWMutex
	createLRPDeploymentArgsForCall []struct {
		logger lager.Logger
		lrp    *models.LRPDeploymentCreation
	}
	createLRPDeploymentReturns struct {
		result1 *models.LRPDeployment
		result2 error
	}
	createLRPDeploymentReturnsOnCall map[int]struct {
		result1 *models.LRPDeployment
		result2 error
	}
	UpdateLRPDeploymentStub        func(logger lager.Logger, id string, definition *models.LRPDeploymentUpdate) (*models.LRPDeployment, error)
	updateLRPDeploymentMutex       sync.RWMutex
	updateLRPDeploymentArgsForCall []struct {
		logger     lager.Logger
		id         string
		definition *models.LRPDeploymentUpdate
	}
	updateLRPDeploymentReturns struct {
		result1 *models.LRPDeployment
		result2 error
	}
	updateLRPDeploymentReturnsOnCall map[int]struct {
		result1 *models.LRPDeployment
		result2 error
	}
	SaveLRPDeploymentStub        func(logger lager.Logger, lrpDeployment *models.LRPDeployment, oldHealthyDefinitionId string) (*models.LRPDeployment, error)
	saveLRPDeploymentMutex       sync.RWMutex
	saveLRPDeploymentArgsForCall []struct {
		logger                 lager.Logger
		lrpDeployment          *models.LRPDeployment
		oldHealthyDefinitionId string
	}
	saveLRPDeploymentReturns struct {
		result1 *models.LRPDeployment
		result2 error
	}
	saveLRPDeploymentReturnsOnCall map[int]struct {
		result1 *models.LRPDeployment
		result2 error
	}
	DeleteLRPDeploymentStub        func(logger lager.Logger, id string) (*models.LRPDeployment, error)
	deleteLRPDeploymentMutex       sync.RWMutex
	deleteLRPDeploymentArgsForCall []struct {
		logger lager.Logger
		id     string
	}
	deleteLRPDeploymentReturns struct {
		result1 *models.LRPDeployment
		result2 error
	}
	deleteLRPDeploymentReturnsOnCall map[int]struct {
		result1 *models.LRPDeployment
		result2 error
	}
	ActivateLRPDeploymentDefinitionStub        func(logger lager.Logger, id string, definitionID string) (*models.LRPDeployment, error)
	activateLRPDeploymentDefinitionMutex       sync.RWMutex
	activateLRPDeploymentDefinitionArgsForCall []struct {
		logger       lager.Logger
		id           string
		definitionID string
	}
	activateLRPDeploymentDefinitionReturns struct {
		result1 *models.LRPDeployment
		result2 error
	}
	activateLRPDeploymentDefinitionReturnsOnCall map[int]struct {
		result1 *models.LRPDeployment
		result2 error
	}
	LRPDeploymentByProcessGuidStub        func(logger lager.Logger, id string) (*models.LRPDeployment, error)
	lRPDeploymentByProcessGuidMutex       sync.RWMutex
	lRPDeploymentByProcessGuidArgsForCall []struct {
		logger lager.Logger
		id     string
	}
	lRPDeploymentByProcessGuidReturns struct {
		result1 *models.LRPDeployment
		result2 error
	}
	lRPDeploymentByProcessGuidReturnsOnCall map[int]struct {
		result1 *models.LRPDeployment
		result2 error
	}
	LRPDeploymentsStub        func(logger lager.Logger, deploymentIds []string) ([]*models.LRPDeployment, error)
	lRPDeploymentsMutex       sync.RWMutex
	lRPDeploymentsArgsForCall []struct {
		logger        lager.Logger
		deploymentIds []string
	}
	lRPDeploymentsReturns struct {
		result1 []*models.LRPDeployment
		result2 error
	}
	lRPDeploymentsReturnsOnCall map[int]struct {
		result1 []*models.LRPDeployment
		result2 error
	}
	LRPDeploymentSchedulingInfoStub        func(logger lager.Logger, filter models.LRPDeploymentFilter) ([]*models.LRPDeploymentSchedulingInfo, error)
	lRPDeploymentSchedulingInfoMutex       sync.RWMutex
	lRPDeploymentSchedulingInfoArgsForCall []struct {
		logger lager.Logger
		filter models.LRPDeploymentFilter
	}
	lRPDeploymentSchedulingInfoReturns struct {
		result1 []*models.LRPDeploymentSchedulingInfo
		result2 error
	}
	lRPDeploymentSchedulingInfoReturnsOnCall map[int]struct {
		result1 []*models.LRPDeploymentSchedulingInfo
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLRPDeploymentDB) CreateLRPDeployment(logger lager.Logger, lrp *models.LRPDeploymentCreation) (*models.LRPDeployment, error) {
	fake.createLRPDeploymentMutex.Lock()
	ret, specificReturn := fake.createLRPDeploymentReturnsOnCall[len(fake.createLRPDeploymentArgsForCall)]
	fake.createLRPDeploymentArgsForCall = append(fake.createLRPDeploymentArgsForCall, struct {
		logger lager.Logger
		lrp    *models.LRPDeploymentCreation
	}{logger, lrp})
	fake.recordInvocation("CreateLRPDeployment", []interface{}{logger, lrp})
	fake.createLRPDeploymentMutex.Unlock()
	if fake.CreateLRPDeploymentStub != nil {
		return fake.CreateLRPDeploymentStub(logger, lrp)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createLRPDeploymentReturns.result1, fake.createLRPDeploymentReturns.result2
}

func (fake *FakeLRPDeploymentDB) CreateLRPDeploymentCallCount() int {
	fake.createLRPDeploymentMutex.RLock()
	defer fake.createLRPDeploymentMutex.RUnlock()
	return len(fake.createLRPDeploymentArgsForCall)
}

func (fake *FakeLRPDeploymentDB) CreateLRPDeploymentArgsForCall(i int) (lager.Logger, *models.LRPDeploymentCreation) {
	fake.createLRPDeploymentMutex.RLock()
	defer fake.createLRPDeploymentMutex.RUnlock()
	return fake.createLRPDeploymentArgsForCall[i].logger, fake.createLRPDeploymentArgsForCall[i].lrp
}

func (fake *FakeLRPDeploymentDB) CreateLRPDeploymentReturns(result1 *models.LRPDeployment, result2 error) {
	fake.CreateLRPDeploymentStub = nil
	fake.createLRPDeploymentReturns = struct {
		result1 *models.LRPDeployment
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) CreateLRPDeploymentReturnsOnCall(i int, result1 *models.LRPDeployment, result2 error) {
	fake.CreateLRPDeploymentStub = nil
	if fake.createLRPDeploymentReturnsOnCall == nil {
		fake.createLRPDeploymentReturnsOnCall = make(map[int]struct {
			result1 *models.LRPDeployment
			result2 error
		})
	}
	fake.createLRPDeploymentReturnsOnCall[i] = struct {
		result1 *models.LRPDeployment
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) UpdateLRPDeployment(logger lager.Logger, id string, definition *models.LRPDeploymentUpdate) (*models.LRPDeployment, error) {
	fake.updateLRPDeploymentMutex.Lock()
	ret, specificReturn := fake.updateLRPDeploymentReturnsOnCall[len(fake.updateLRPDeploymentArgsForCall)]
	fake.updateLRPDeploymentArgsForCall = append(fake.updateLRPDeploymentArgsForCall, struct {
		logger     lager.Logger
		id         string
		definition *models.LRPDeploymentUpdate
	}{logger, id, definition})
	fake.recordInvocation("UpdateLRPDeployment", []interface{}{logger, id, definition})
	fake.updateLRPDeploymentMutex.Unlock()
	if fake.UpdateLRPDeploymentStub != nil {
		return fake.UpdateLRPDeploymentStub(logger, id, definition)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateLRPDeploymentReturns.result1, fake.updateLRPDeploymentReturns.result2
}

func (fake *FakeLRPDeploymentDB) UpdateLRPDeploymentCallCount() int {
	fake.updateLRPDeploymentMutex.RLock()
	defer fake.updateLRPDeploymentMutex.RUnlock()
	return len(fake.updateLRPDeploymentArgsForCall)
}

func (fake *FakeLRPDeploymentDB) UpdateLRPDeploymentArgsForCall(i int) (lager.Logger, string, *models.LRPDeploymentUpdate) {
	fake.updateLRPDeploymentMutex.RLock()
	defer fake.updateLRPDeploymentMutex.RUnlock()
	return fake.updateLRPDeploymentArgsForCall[i].logger, fake.updateLRPDeploymentArgsForCall[i].id, fake.updateLRPDeploymentArgsForCall[i].definition
}

func (fake *FakeLRPDeploymentDB) UpdateLRPDeploymentReturns(result1 *models.LRPDeployment, result2 error) {
	fake.UpdateLRPDeploymentStub = nil
	fake.updateLRPDeploymentReturns = struct {
		result1 *models.LRPDeployment
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) UpdateLRPDeploymentReturnsOnCall(i int, result1 *models.LRPDeployment, result2 error) {
	fake.UpdateLRPDeploymentStub = nil
	if fake.updateLRPDeploymentReturnsOnCall == nil {
		fake.updateLRPDeploymentReturnsOnCall = make(map[int]struct {
			result1 *models.LRPDeployment
			result2 error
		})
	}
	fake.updateLRPDeploymentReturnsOnCall[i] = struct {
		result1 *models.LRPDeployment
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) SaveLRPDeployment(logger lager.Logger, lrpDeployment *models.LRPDeployment, oldHealthyDefinitionId string) (*models.LRPDeployment, error) {
	fake.saveLRPDeploymentMutex.Lock()
	ret, specificReturn := fake.saveLRPDeploymentReturnsOnCall[len(fake.saveLRPDeploymentArgsForCall)]
	fake.saveLRPDeploymentArgsForCall = append(fake.saveLRPDeploymentArgsForCall, struct {
		logger                 lager.Logger
		lrpDeployment          *models.LRPDeployment
		oldHealthyDefinitionId string
	}{logger, lrpDeployment, oldHealthyDefinitionId})
	fake.recordInvocation("SaveLRPDeployment", []interface{}{logger, lrpDeployment, oldHealthyDefinitionId})
	fake.saveLRPDeploymentMutex.Unlock()
	if fake.SaveLRPDeploymentStub != nil {
		return fake.SaveLRPDeploymentStub(logger, lrpDeployment, oldHealthyDefinitionId)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.saveLRPDeploymentReturns.result1, fake.saveLRPDeploymentReturns.result2
}

func (fake *FakeLRPDeploymentDB) SaveLRPDeploymentCallCount() int {
	fake.saveLRPDeploymentMutex.RLock()
	defer fake.saveLRPDeploymentMutex.RUnlock()
	return len(fake.saveLRPDeploymentArgsForCall)
}

func (fake *FakeLRPDeploymentDB) SaveLRPDeploymentArgsForCall(i int) (lager.Logger, *models.LRPDeployment, string) {
	fake.saveLRPDeploymentMutex.RLock()
	defer fake.saveLRPDeploymentMutex.RUnlock()
	return fake.saveLRPDeploymentArgsForCall[i].logger, fake.saveLRPDeploymentArgsForCall[i].lrpDeployment, fake.saveLRPDeploymentArgsForCall[i].oldHealthyDefinitionId
}

func (fake *FakeLRPDeploymentDB) SaveLRPDeploymentReturns(result1 *models.LRPDeployment, result2 error) {
	fake.SaveLRPDeploymentStub = nil
	fake.saveLRPDeploymentReturns = struct {
		result1 *models.LRPDeployment
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) SaveLRPDeploymentReturnsOnCall(i int, result1 *models.LRPDeployment, result2 error) {
	fake.SaveLRPDeploymentStub = nil
	if fake.saveLRPDeploymentReturnsOnCall == nil {
		fake.saveLRPDeploymentReturnsOnCall = make(map[int]struct {
			result1 *models.LRPDeployment
			result2 error
		})
	}
	fake.saveLRPDeploymentReturnsOnCall[i] = struct {
		result1 *models.LRPDeployment
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) DeleteLRPDeployment(logger lager.Logger, id string) (*models.LRPDeployment, error) {
	fake.deleteLRPDeploymentMutex.Lock()
	ret, specificReturn := fake.deleteLRPDeploymentReturnsOnCall[len(fake.deleteLRPDeploymentArgsForCall)]
	fake.deleteLRPDeploymentArgsForCall = append(fake.deleteLRPDeploymentArgsForCall, struct {
		logger lager.Logger
		id     string
	}{logger, id})
	fake.recordInvocation("DeleteLRPDeployment", []interface{}{logger, id})
	fake.deleteLRPDeploymentMutex.Unlock()
	if fake.DeleteLRPDeploymentStub != nil {
		return fake.DeleteLRPDeploymentStub(logger, id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deleteLRPDeploymentReturns.result1, fake.deleteLRPDeploymentReturns.result2
}

func (fake *FakeLRPDeploymentDB) DeleteLRPDeploymentCallCount() int {
	fake.deleteLRPDeploymentMutex.RLock()
	defer fake.deleteLRPDeploymentMutex.RUnlock()
	return len(fake.deleteLRPDeploymentArgsForCall)
}

func (fake *FakeLRPDeploymentDB) DeleteLRPDeploymentArgsForCall(i int) (lager.Logger, string) {
	fake.deleteLRPDeploymentMutex.RLock()
	defer fake.deleteLRPDeploymentMutex.RUnlock()
	return fake.deleteLRPDeploymentArgsForCall[i].logger, fake.deleteLRPDeploymentArgsForCall[i].id
}

func (fake *FakeLRPDeploymentDB) DeleteLRPDeploymentReturns(result1 *models.LRPDeployment, result2 error) {
	fake.DeleteLRPDeploymentStub = nil
	fake.deleteLRPDeploymentReturns = struct {
		result1 *models.LRPDeployment
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) DeleteLRPDeploymentReturnsOnCall(i int, result1 *models.LRPDeployment, result2 error) {
	fake.DeleteLRPDeploymentStub = nil
	if fake.deleteLRPDeploymentReturnsOnCall == nil {
		fake.deleteLRPDeploymentReturnsOnCall = make(map[int]struct {
			result1 *models.LRPDeployment
			result2 error
		})
	}
	fake.deleteLRPDeploymentReturnsOnCall[i] = struct {
		result1 *models.LRPDeployment
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) ActivateLRPDeploymentDefinition(logger lager.Logger, id string, definitionID string) (*models.LRPDeployment, error) {
	fake.activateLRPDeploymentDefinitionMutex.Lock()
	ret, specificReturn := fake.activateLRPDeploymentDefinitionReturnsOnCall[len(fake.activateLRPDeploymentDefinitionArgsForCall)]
	fake.activateLRPDeploymentDefinitionArgsForCall = append(fake.activateLRPDeploymentDefinitionArgsForCall, struct {
		logger       lager.Logger
		id           string
		definitionID string
	}{logger, id, definitionID})
	fake.recordInvocation("ActivateLRPDeploymentDefinition", []interface{}{logger, id, definitionID})
	fake.activateLRPDeploymentDefinitionMutex.Unlock()
	if fake.ActivateLRPDeploymentDefinitionStub != nil {
		return fake.ActivateLRPDeploymentDefinitionStub(logger, id, definitionID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.activateLRPDeploymentDefinitionReturns.result1, fake.activateLRPDeploymentDefinitionReturns.result2
}

func (fake *FakeLRPDeploymentDB) ActivateLRPDeploymentDefinitionCallCount() int {
	fake.activateLRPDeploymentDefinitionMutex.RLock()
	defer fake.activateLRPDeploymentDefinitionMutex.RUnlock()
	return len(fake.activateLRPDeploymentDefinitionArgsForCall)
}

func (fake *FakeLRPDeploymentDB) ActivateLRPDeploymentDefinitionArgsForCall(i int) (lager.Logger, string, string) {
	fake.activateLRPDeploymentDefinitionMutex.RLock()
	defer fake.activateLRPDeploymentDefinitionMutex.RUnlock()
	return fake.activateLRPDeploymentDefinitionArgsForCall[i].logger, fake.activateLRPDeploymentDefinitionArgsForCall[i].id, fake.activateLRPDeploymentDefinitionArgsForCall[i].definitionID
}

func (fake *FakeLRPDeploymentDB) ActivateLRPDeploymentDefinitionReturns(result1 *models.LRPDeployment, result2 error) {
	fake.ActivateLRPDeploymentDefinitionStub = nil
	fake.activateLRPDeploymentDefinitionReturns = struct {
		result1 *models.LRPDeployment
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) ActivateLRPDeploymentDefinitionReturnsOnCall(i int, result1 *models.LRPDeployment, result2 error) {
	fake.ActivateLRPDeploymentDefinitionStub = nil
	if fake.activateLRPDeploymentDefinitionReturnsOnCall == nil {
		fake.activateLRPDeploymentDefinitionReturnsOnCall = make(map[int]struct {
			result1 *models.LRPDeployment
			result2 error
		})
	}
	fake.activateLRPDeploymentDefinitionReturnsOnCall[i] = struct {
		result1 *models.LRPDeployment
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) LRPDeploymentByProcessGuid(logger lager.Logger, id string) (*models.LRPDeployment, error) {
	fake.lRPDeploymentByProcessGuidMutex.Lock()
	ret, specificReturn := fake.lRPDeploymentByProcessGuidReturnsOnCall[len(fake.lRPDeploymentByProcessGuidArgsForCall)]
	fake.lRPDeploymentByProcessGuidArgsForCall = append(fake.lRPDeploymentByProcessGuidArgsForCall, struct {
		logger lager.Logger
		id     string
	}{logger, id})
	fake.recordInvocation("LRPDeploymentByProcessGuid", []interface{}{logger, id})
	fake.lRPDeploymentByProcessGuidMutex.Unlock()
	if fake.LRPDeploymentByProcessGuidStub != nil {
		return fake.LRPDeploymentByProcessGuidStub(logger, id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.lRPDeploymentByProcessGuidReturns.result1, fake.lRPDeploymentByProcessGuidReturns.result2
}

func (fake *FakeLRPDeploymentDB) LRPDeploymentByProcessGuidCallCount() int {
	fake.lRPDeploymentByProcessGuidMutex.RLock()
	defer fake.lRPDeploymentByProcessGuidMutex.RUnlock()
	return len(fake.lRPDeploymentByProcessGuidArgsForCall)
}

func (fake *FakeLRPDeploymentDB) LRPDeploymentByProcessGuidArgsForCall(i int) (lager.Logger, string) {
	fake.lRPDeploymentByProcessGuidMutex.RLock()
	defer fake.lRPDeploymentByProcessGuidMutex.RUnlock()
	return fake.lRPDeploymentByProcessGuidArgsForCall[i].logger, fake.lRPDeploymentByProcessGuidArgsForCall[i].id
}

func (fake *FakeLRPDeploymentDB) LRPDeploymentByProcessGuidReturns(result1 *models.LRPDeployment, result2 error) {
	fake.LRPDeploymentByProcessGuidStub = nil
	fake.lRPDeploymentByProcessGuidReturns = struct {
		result1 *models.LRPDeployment
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) LRPDeploymentByProcessGuidReturnsOnCall(i int, result1 *models.LRPDeployment, result2 error) {
	fake.LRPDeploymentByProcessGuidStub = nil
	if fake.lRPDeploymentByProcessGuidReturnsOnCall == nil {
		fake.lRPDeploymentByProcessGuidReturnsOnCall = make(map[int]struct {
			result1 *models.LRPDeployment
			result2 error
		})
	}
	fake.lRPDeploymentByProcessGuidReturnsOnCall[i] = struct {
		result1 *models.LRPDeployment
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) LRPDeployments(logger lager.Logger, deploymentIds []string) ([]*models.LRPDeployment, error) {
	var deploymentIdsCopy []string
	if deploymentIds != nil {
		deploymentIdsCopy = make([]string, len(deploymentIds))
		copy(deploymentIdsCopy, deploymentIds)
	}
	fake.lRPDeploymentsMutex.Lock()
	ret, specificReturn := fake.lRPDeploymentsReturnsOnCall[len(fake.lRPDeploymentsArgsForCall)]
	fake.lRPDeploymentsArgsForCall = append(fake.lRPDeploymentsArgsForCall, struct {
		logger        lager.Logger
		deploymentIds []string
	}{logger, deploymentIdsCopy})
	fake.recordInvocation("LRPDeployments", []interface{}{logger, deploymentIdsCopy})
	fake.lRPDeploymentsMutex.Unlock()
	if fake.LRPDeploymentsStub != nil {
		return fake.LRPDeploymentsStub(logger, deploymentIds)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.lRPDeploymentsReturns.result1, fake.lRPDeploymentsReturns.result2
}

func (fake *FakeLRPDeploymentDB) LRPDeploymentsCallCount() int {
	fake.lRPDeploymentsMutex.RLock()
	defer fake.lRPDeploymentsMutex.RUnlock()
	return len(fake.lRPDeploymentsArgsForCall)
}

func (fake *FakeLRPDeploymentDB) LRPDeploymentsArgsForCall(i int) (lager.Logger, []string) {
	fake.lRPDeploymentsMutex.RLock()
	defer fake.lRPDeploymentsMutex.RUnlock()
	return fake.lRPDeploymentsArgsForCall[i].logger, fake.lRPDeploymentsArgsForCall[i].deploymentIds
}

func (fake *FakeLRPDeploymentDB) LRPDeploymentsReturns(result1 []*models.LRPDeployment, result2 error) {
	fake.LRPDeploymentsStub = nil
	fake.lRPDeploymentsReturns = struct {
		result1 []*models.LRPDeployment
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) LRPDeploymentsReturnsOnCall(i int, result1 []*models.LRPDeployment, result2 error) {
	fake.LRPDeploymentsStub = nil
	if fake.lRPDeploymentsReturnsOnCall == nil {
		fake.lRPDeploymentsReturnsOnCall = make(map[int]struct {
			result1 []*models.LRPDeployment
			result2 error
		})
	}
	fake.lRPDeploymentsReturnsOnCall[i] = struct {
		result1 []*models.LRPDeployment
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) LRPDeploymentSchedulingInfo(logger lager.Logger, filter models.LRPDeploymentFilter) ([]*models.LRPDeploymentSchedulingInfo, error) {
	fake.lRPDeploymentSchedulingInfoMutex.Lock()
	ret, specificReturn := fake.lRPDeploymentSchedulingInfoReturnsOnCall[len(fake.lRPDeploymentSchedulingInfoArgsForCall)]
	fake.lRPDeploymentSchedulingInfoArgsForCall = append(fake.lRPDeploymentSchedulingInfoArgsForCall, struct {
		logger lager.Logger
		filter models.LRPDeploymentFilter
	}{logger, filter})
	fake.recordInvocation("LRPDeploymentSchedulingInfo", []interface{}{logger, filter})
	fake.lRPDeploymentSchedulingInfoMutex.Unlock()
	if fake.LRPDeploymentSchedulingInfoStub != nil {
		return fake.LRPDeploymentSchedulingInfoStub(logger, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.lRPDeploymentSchedulingInfoReturns.result1, fake.lRPDeploymentSchedulingInfoReturns.result2
}

func (fake *FakeLRPDeploymentDB) LRPDeploymentSchedulingInfoCallCount() int {
	fake.lRPDeploymentSchedulingInfoMutex.RLock()
	defer fake.lRPDeploymentSchedulingInfoMutex.RUnlock()
	return len(fake.lRPDeploymentSchedulingInfoArgsForCall)
}

func (fake *FakeLRPDeploymentDB) LRPDeploymentSchedulingInfoArgsForCall(i int) (lager.Logger, models.LRPDeploymentFilter) {
	fake.lRPDeploymentSchedulingInfoMutex.RLock()
	defer fake.lRPDeploymentSchedulingInfoMutex.RUnlock()
	return fake.lRPDeploymentSchedulingInfoArgsForCall[i].logger, fake.lRPDeploymentSchedulingInfoArgsForCall[i].filter
}

func (fake *FakeLRPDeploymentDB) LRPDeploymentSchedulingInfoReturns(result1 []*models.LRPDeploymentSchedulingInfo, result2 error) {
	fake.LRPDeploymentSchedulingInfoStub = nil
	fake.lRPDeploymentSchedulingInfoReturns = struct {
		result1 []*models.LRPDeploymentSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) LRPDeploymentSchedulingInfoReturnsOnCall(i int, result1 []*models.LRPDeploymentSchedulingInfo, result2 error) {
	fake.LRPDeploymentSchedulingInfoStub = nil
	if fake.lRPDeploymentSchedulingInfoReturnsOnCall == nil {
		fake.lRPDeploymentSchedulingInfoReturnsOnCall = make(map[int]struct {
			result1 []*models.LRPDeploymentSchedulingInfo
			result2 error
		})
	}
	fake.lRPDeploymentSchedulingInfoReturnsOnCall[i] = struct {
		result1 []*models.LRPDeploymentSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeLRPDeploymentDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createLRPDeploymentMutex.RLock()
	defer fake.createLRPDeploymentMutex.RUnlock()
	fake.updateLRPDeploymentMutex.RLock()
	defer fake.updateLRPDeploymentMutex.RUnlock()
	fake.saveLRPDeploymentMutex.RLock()
	defer fake.saveLRPDeploymentMutex.RUnlock()
	fake.deleteLRPDeploymentMutex.RLock()
	defer fake.deleteLRPDeploymentMutex.RUnlock()
	fake.activateLRPDeploymentDefinitionMutex.RLock()
	defer fake.activateLRPDeploymentDefinitionMutex.RUnlock()
	fake.lRPDeploymentByProcessGuidMutex.RLock()
	defer fake.lRPDeploymentByProcessGuidMutex.RUnlock()
	fake.lRPDeploymentsMutex.RLock()
	defer fake.lRPDeploymentsMutex.RUnlock()
	fake.lRPDeploymentSchedulingInfoMutex.RLock()
	defer fake.lRPDeploymentSchedulingInfoMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLRPDeploymentDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.LRPDeploymentDB = new(FakeLRPDeploymentDB)
