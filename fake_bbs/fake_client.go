// This file was generated by counterfeiter
package fake_bbs

import (
	"sync"
	"time"

	"github.com/cloudfoundry-incubator/bbs"
	"github.com/cloudfoundry-incubator/bbs/events"
	"github.com/cloudfoundry-incubator/bbs/models"
)

type FakeClient struct {
	DomainsStub        func() ([]string, *models.Error)
	domainsMutex       sync.RWMutex
	domainsArgsForCall []struct{}
	domainsReturns struct {
		result1 []string
		result2 *models.Error
	}
	UpsertDomainStub        func(domain string, ttl time.Duration) *models.Error
	upsertDomainMutex       sync.RWMutex
	upsertDomainArgsForCall []struct {
		domain string
		ttl    time.Duration
	}
	upsertDomainReturns struct {
		result1 *models.Error
	}
	ActualLRPGroupsStub        func(models.ActualLRPFilter) ([]*models.ActualLRPGroup, *models.Error)
	actualLRPGroupsMutex       sync.RWMutex
	actualLRPGroupsArgsForCall []struct {
		arg1 models.ActualLRPFilter
	}
	actualLRPGroupsReturns struct {
		result1 []*models.ActualLRPGroup
		result2 *models.Error
	}
	ActualLRPGroupsByProcessGuidStub        func(processGuid string) ([]*models.ActualLRPGroup, *models.Error)
	actualLRPGroupsByProcessGuidMutex       sync.RWMutex
	actualLRPGroupsByProcessGuidArgsForCall []struct {
		processGuid string
	}
	actualLRPGroupsByProcessGuidReturns struct {
		result1 []*models.ActualLRPGroup
		result2 *models.Error
	}
	ActualLRPGroupByProcessGuidAndIndexStub        func(processGuid string, index int) (*models.ActualLRPGroup, *models.Error)
	actualLRPGroupByProcessGuidAndIndexMutex       sync.RWMutex
	actualLRPGroupByProcessGuidAndIndexArgsForCall []struct {
		processGuid string
		index       int
	}
	actualLRPGroupByProcessGuidAndIndexReturns struct {
		result1 *models.ActualLRPGroup
		result2 *models.Error
	}
	ClaimActualLRPStub        func(processGuid string, index int, instanceKey *models.ActualLRPInstanceKey) *models.Error
	claimActualLRPMutex       sync.RWMutex
	claimActualLRPArgsForCall []struct {
		processGuid string
		index       int
		instanceKey *models.ActualLRPInstanceKey
	}
	claimActualLRPReturns struct {
		result1 *models.Error
	}
	StartActualLRPStub        func(key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, netInfo *models.ActualLRPNetInfo) *models.Error
	startActualLRPMutex       sync.RWMutex
	startActualLRPArgsForCall []struct {
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		netInfo     *models.ActualLRPNetInfo
	}
	startActualLRPReturns struct {
		result1 *models.Error
	}
	CrashActualLRPStub        func(key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, errorMessage string) *models.Error
	crashActualLRPMutex       sync.RWMutex
	crashActualLRPArgsForCall []struct {
		key          *models.ActualLRPKey
		instanceKey  *models.ActualLRPInstanceKey
		errorMessage string
	}
	crashActualLRPReturns struct {
		result1 *models.Error
	}
	FailActualLRPStub        func(key *models.ActualLRPKey, errorMessage string) *models.Error
	failActualLRPMutex       sync.RWMutex
	failActualLRPArgsForCall []struct {
		key          *models.ActualLRPKey
		errorMessage string
	}
	failActualLRPReturns struct {
		result1 *models.Error
	}
	RemoveActualLRPStub        func(processGuid string, index int) *models.Error
	removeActualLRPMutex       sync.RWMutex
	removeActualLRPArgsForCall []struct {
		processGuid string
		index       int
	}
	removeActualLRPReturns struct {
		result1 *models.Error
	}
	RetireActualLRPStub        func(key *models.ActualLRPKey) *models.Error
	retireActualLRPMutex       sync.RWMutex
	retireActualLRPArgsForCall []struct {
		key *models.ActualLRPKey
	}
	retireActualLRPReturns struct {
		result1 *models.Error
	}
	EvacuateClaimedActualLRPStub        func(*models.ActualLRPKey, *models.ActualLRPInstanceKey) (bool, *models.Error)
	evacuateClaimedActualLRPMutex       sync.RWMutex
	evacuateClaimedActualLRPArgsForCall []struct {
		arg1 *models.ActualLRPKey
		arg2 *models.ActualLRPInstanceKey
	}
	evacuateClaimedActualLRPReturns struct {
		result1 bool
		result2 *models.Error
	}
	EvacuateRunningActualLRPStub        func(*models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo, uint64) (bool, *models.Error)
	evacuateRunningActualLRPMutex       sync.RWMutex
	evacuateRunningActualLRPArgsForCall []struct {
		arg1 *models.ActualLRPKey
		arg2 *models.ActualLRPInstanceKey
		arg3 *models.ActualLRPNetInfo
		arg4 uint64
	}
	evacuateRunningActualLRPReturns struct {
		result1 bool
		result2 *models.Error
	}
	EvacuateStoppedActualLRPStub        func(*models.ActualLRPKey, *models.ActualLRPInstanceKey) (bool, *models.Error)
	evacuateStoppedActualLRPMutex       sync.RWMutex
	evacuateStoppedActualLRPArgsForCall []struct {
		arg1 *models.ActualLRPKey
		arg2 *models.ActualLRPInstanceKey
	}
	evacuateStoppedActualLRPReturns struct {
		result1 bool
		result2 *models.Error
	}
	EvacuateCrashedActualLRPStub        func(*models.ActualLRPKey, *models.ActualLRPInstanceKey, string) (bool, *models.Error)
	evacuateCrashedActualLRPMutex       sync.RWMutex
	evacuateCrashedActualLRPArgsForCall []struct {
		arg1 *models.ActualLRPKey
		arg2 *models.ActualLRPInstanceKey
		arg3 string
	}
	evacuateCrashedActualLRPReturns struct {
		result1 bool
		result2 *models.Error
	}
	RemoveEvacuatingActualLRPStub        func(*models.ActualLRPKey, *models.ActualLRPInstanceKey) *models.Error
	removeEvacuatingActualLRPMutex       sync.RWMutex
	removeEvacuatingActualLRPArgsForCall []struct {
		arg1 *models.ActualLRPKey
		arg2 *models.ActualLRPInstanceKey
	}
	removeEvacuatingActualLRPReturns struct {
		result1 *models.Error
	}
	DesiredLRPsStub        func(models.DesiredLRPFilter) ([]*models.DesiredLRP, *models.Error)
	desiredLRPsMutex       sync.RWMutex
	desiredLRPsArgsForCall []struct {
		arg1 models.DesiredLRPFilter
	}
	desiredLRPsReturns struct {
		result1 []*models.DesiredLRP
		result2 *models.Error
	}
	DesiredLRPByProcessGuidStub        func(processGuid string) (*models.DesiredLRP, *models.Error)
	desiredLRPByProcessGuidMutex       sync.RWMutex
	desiredLRPByProcessGuidArgsForCall []struct {
		processGuid string
	}
	desiredLRPByProcessGuidReturns struct {
		result1 *models.DesiredLRP
		result2 *models.Error
	}
	DesireLRPStub        func(*models.DesiredLRP) *models.Error
	desireLRPMutex       sync.RWMutex
	desireLRPArgsForCall []struct {
		arg1 *models.DesiredLRP
	}
	desireLRPReturns struct {
		result1 *models.Error
	}
	UpdateDesiredLRPStub        func(processGuid string, update *models.DesiredLRPUpdate) *models.Error
	updateDesiredLRPMutex       sync.RWMutex
	updateDesiredLRPArgsForCall []struct {
		processGuid string
		update      *models.DesiredLRPUpdate
	}
	updateDesiredLRPReturns struct {
		result1 *models.Error
	}
	RemoveDesiredLRPStub        func(processGuid string) *models.Error
	removeDesiredLRPMutex       sync.RWMutex
	removeDesiredLRPArgsForCall []struct {
		processGuid string
	}
	removeDesiredLRPReturns struct {
		result1 *models.Error
	}
	ConvergeLRPsStub        func() *models.Error
	convergeLRPsMutex       sync.RWMutex
	convergeLRPsArgsForCall []struct{}
	convergeLRPsReturns struct {
		result1 *models.Error
	}
	TasksStub        func() ([]*models.Task, *models.Error)
	tasksMutex       sync.RWMutex
	tasksArgsForCall []struct{}
	tasksReturns struct {
		result1 []*models.Task
		result2 *models.Error
	}
	TasksByDomainStub        func(domain string) ([]*models.Task, *models.Error)
	tasksByDomainMutex       sync.RWMutex
	tasksByDomainArgsForCall []struct {
		domain string
	}
	tasksByDomainReturns struct {
		result1 []*models.Task
		result2 *models.Error
	}
	TasksByCellIDStub        func(cellId string) ([]*models.Task, *models.Error)
	tasksByCellIDMutex       sync.RWMutex
	tasksByCellIDArgsForCall []struct {
		cellId string
	}
	tasksByCellIDReturns struct {
		result1 []*models.Task
		result2 *models.Error
	}
	TaskByGuidStub        func(guid string) (*models.Task, *models.Error)
	taskByGuidMutex       sync.RWMutex
	taskByGuidArgsForCall []struct {
		guid string
	}
	taskByGuidReturns struct {
		result1 *models.Task
		result2 *models.Error
	}
	DesireTaskStub        func(guid, domain string, def *models.TaskDefinition) *models.Error
	desireTaskMutex       sync.RWMutex
	desireTaskArgsForCall []struct {
		guid   string
		domain string
		def    *models.TaskDefinition
	}
	desireTaskReturns struct {
		result1 *models.Error
	}
	CancelTaskStub        func(taskGuid string) *models.Error
	cancelTaskMutex       sync.RWMutex
	cancelTaskArgsForCall []struct {
		taskGuid string
	}
	cancelTaskReturns struct {
		result1 *models.Error
	}
	FailTaskStub        func(taskGuid, failureReason string) *models.Error
	failTaskMutex       sync.RWMutex
	failTaskArgsForCall []struct {
		taskGuid      string
		failureReason string
	}
	failTaskReturns struct {
		result1 *models.Error
	}
	CompleteTaskStub        func(taskGuid, cellId string, failed bool, failureReason, result string) *models.Error
	completeTaskMutex       sync.RWMutex
	completeTaskArgsForCall []struct {
		taskGuid      string
		cellId        string
		failed        bool
		failureReason string
		result        string
	}
	completeTaskReturns struct {
		result1 *models.Error
	}
	ResolvingTaskStub        func(taskGuid string) *models.Error
	resolvingTaskMutex       sync.RWMutex
	resolvingTaskArgsForCall []struct {
		taskGuid string
	}
	resolvingTaskReturns struct {
		result1 *models.Error
	}
	DeleteTaskStub        func(taskGuid string) *models.Error
	deleteTaskMutex       sync.RWMutex
	deleteTaskArgsForCall []struct {
		taskGuid string
	}
	deleteTaskReturns struct {
		result1 *models.Error
	}
	ConvergeTasksStub        func(kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration time.Duration) *models.Error
	convergeTasksMutex       sync.RWMutex
	convergeTasksArgsForCall []struct {
		kickTaskDuration            time.Duration
		expirePendingTaskDuration   time.Duration
		expireCompletedTaskDuration time.Duration
	}
	convergeTasksReturns struct {
		result1 *models.Error
	}
	SubscribeToEventsStub        func() (events.EventSource, *models.Error)
	subscribeToEventsMutex       sync.RWMutex
	subscribeToEventsArgsForCall []struct{}
	subscribeToEventsReturns struct {
		result1 events.EventSource
		result2 *models.Error
	}
	StartTaskStub        func(taskGuid string, cellID string) (bool, *models.Error)
	startTaskMutex       sync.RWMutex
	startTaskArgsForCall []struct {
		taskGuid string
		cellID   string
	}
	startTaskReturns struct {
		result1 bool
		result2 *models.Error
	}
}

func (fake *FakeClient) Domains() ([]string, *models.Error) {
	fake.domainsMutex.Lock()
	fake.domainsArgsForCall = append(fake.domainsArgsForCall, struct{}{})
	fake.domainsMutex.Unlock()
	if fake.DomainsStub != nil {
		return fake.DomainsStub()
	} else {
		return fake.domainsReturns.result1, fake.domainsReturns.result2
	}
}

func (fake *FakeClient) DomainsCallCount() int {
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	return len(fake.domainsArgsForCall)
}

func (fake *FakeClient) DomainsReturns(result1 []string, result2 *models.Error) {
	fake.DomainsStub = nil
	fake.domainsReturns = struct {
		result1 []string
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) UpsertDomain(domain string, ttl time.Duration) *models.Error {
	fake.upsertDomainMutex.Lock()
	fake.upsertDomainArgsForCall = append(fake.upsertDomainArgsForCall, struct {
		domain string
		ttl    time.Duration
	}{domain, ttl})
	fake.upsertDomainMutex.Unlock()
	if fake.UpsertDomainStub != nil {
		return fake.UpsertDomainStub(domain, ttl)
	} else {
		return fake.upsertDomainReturns.result1
	}
}

func (fake *FakeClient) UpsertDomainCallCount() int {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	return len(fake.upsertDomainArgsForCall)
}

func (fake *FakeClient) UpsertDomainArgsForCall(i int) (string, time.Duration) {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	return fake.upsertDomainArgsForCall[i].domain, fake.upsertDomainArgsForCall[i].ttl
}

func (fake *FakeClient) UpsertDomainReturns(result1 *models.Error) {
	fake.UpsertDomainStub = nil
	fake.upsertDomainReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) ActualLRPGroups(arg1 models.ActualLRPFilter) ([]*models.ActualLRPGroup, *models.Error) {
	fake.actualLRPGroupsMutex.Lock()
	fake.actualLRPGroupsArgsForCall = append(fake.actualLRPGroupsArgsForCall, struct {
		arg1 models.ActualLRPFilter
	}{arg1})
	fake.actualLRPGroupsMutex.Unlock()
	if fake.ActualLRPGroupsStub != nil {
		return fake.ActualLRPGroupsStub(arg1)
	} else {
		return fake.actualLRPGroupsReturns.result1, fake.actualLRPGroupsReturns.result2
	}
}

func (fake *FakeClient) ActualLRPGroupsCallCount() int {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	return len(fake.actualLRPGroupsArgsForCall)
}

func (fake *FakeClient) ActualLRPGroupsArgsForCall(i int) models.ActualLRPFilter {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	return fake.actualLRPGroupsArgsForCall[i].arg1
}

func (fake *FakeClient) ActualLRPGroupsReturns(result1 []*models.ActualLRPGroup, result2 *models.Error) {
	fake.ActualLRPGroupsStub = nil
	fake.actualLRPGroupsReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) ActualLRPGroupsByProcessGuid(processGuid string) ([]*models.ActualLRPGroup, *models.Error) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	fake.actualLRPGroupsByProcessGuidArgsForCall = append(fake.actualLRPGroupsByProcessGuidArgsForCall, struct {
		processGuid string
	}{processGuid})
	fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	if fake.ActualLRPGroupsByProcessGuidStub != nil {
		return fake.ActualLRPGroupsByProcessGuidStub(processGuid)
	} else {
		return fake.actualLRPGroupsByProcessGuidReturns.result1, fake.actualLRPGroupsByProcessGuidReturns.result2
	}
}

func (fake *FakeClient) ActualLRPGroupsByProcessGuidCallCount() int {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	return len(fake.actualLRPGroupsByProcessGuidArgsForCall)
}

func (fake *FakeClient) ActualLRPGroupsByProcessGuidArgsForCall(i int) string {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	return fake.actualLRPGroupsByProcessGuidArgsForCall[i].processGuid
}

func (fake *FakeClient) ActualLRPGroupsByProcessGuidReturns(result1 []*models.ActualLRPGroup, result2 *models.Error) {
	fake.ActualLRPGroupsByProcessGuidStub = nil
	fake.actualLRPGroupsByProcessGuidReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) ActualLRPGroupByProcessGuidAndIndex(processGuid string, index int) (*models.ActualLRPGroup, *models.Error) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	fake.actualLRPGroupByProcessGuidAndIndexArgsForCall = append(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall, struct {
		processGuid string
		index       int
	}{processGuid, index})
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	if fake.ActualLRPGroupByProcessGuidAndIndexStub != nil {
		return fake.ActualLRPGroupByProcessGuidAndIndexStub(processGuid, index)
	} else {
		return fake.actualLRPGroupByProcessGuidAndIndexReturns.result1, fake.actualLRPGroupByProcessGuidAndIndexReturns.result2
	}
}

func (fake *FakeClient) ActualLRPGroupByProcessGuidAndIndexCallCount() int {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	return len(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall)
}

func (fake *FakeClient) ActualLRPGroupByProcessGuidAndIndexArgsForCall(i int) (string, int) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	return fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i].processGuid, fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i].index
}

func (fake *FakeClient) ActualLRPGroupByProcessGuidAndIndexReturns(result1 *models.ActualLRPGroup, result2 *models.Error) {
	fake.ActualLRPGroupByProcessGuidAndIndexStub = nil
	fake.actualLRPGroupByProcessGuidAndIndexReturns = struct {
		result1 *models.ActualLRPGroup
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) ClaimActualLRP(processGuid string, index int, instanceKey *models.ActualLRPInstanceKey) *models.Error {
	fake.claimActualLRPMutex.Lock()
	fake.claimActualLRPArgsForCall = append(fake.claimActualLRPArgsForCall, struct {
		processGuid string
		index       int
		instanceKey *models.ActualLRPInstanceKey
	}{processGuid, index, instanceKey})
	fake.claimActualLRPMutex.Unlock()
	if fake.ClaimActualLRPStub != nil {
		return fake.ClaimActualLRPStub(processGuid, index, instanceKey)
	} else {
		return fake.claimActualLRPReturns.result1
	}
}

func (fake *FakeClient) ClaimActualLRPCallCount() int {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return len(fake.claimActualLRPArgsForCall)
}

func (fake *FakeClient) ClaimActualLRPArgsForCall(i int) (string, int, *models.ActualLRPInstanceKey) {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return fake.claimActualLRPArgsForCall[i].processGuid, fake.claimActualLRPArgsForCall[i].index, fake.claimActualLRPArgsForCall[i].instanceKey
}

func (fake *FakeClient) ClaimActualLRPReturns(result1 *models.Error) {
	fake.ClaimActualLRPStub = nil
	fake.claimActualLRPReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) StartActualLRP(key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, netInfo *models.ActualLRPNetInfo) *models.Error {
	fake.startActualLRPMutex.Lock()
	fake.startActualLRPArgsForCall = append(fake.startActualLRPArgsForCall, struct {
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		netInfo     *models.ActualLRPNetInfo
	}{key, instanceKey, netInfo})
	fake.startActualLRPMutex.Unlock()
	if fake.StartActualLRPStub != nil {
		return fake.StartActualLRPStub(key, instanceKey, netInfo)
	} else {
		return fake.startActualLRPReturns.result1
	}
}

func (fake *FakeClient) StartActualLRPCallCount() int {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return len(fake.startActualLRPArgsForCall)
}

func (fake *FakeClient) StartActualLRPArgsForCall(i int) (*models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return fake.startActualLRPArgsForCall[i].key, fake.startActualLRPArgsForCall[i].instanceKey, fake.startActualLRPArgsForCall[i].netInfo
}

func (fake *FakeClient) StartActualLRPReturns(result1 *models.Error) {
	fake.StartActualLRPStub = nil
	fake.startActualLRPReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) CrashActualLRP(key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, errorMessage string) *models.Error {
	fake.crashActualLRPMutex.Lock()
	fake.crashActualLRPArgsForCall = append(fake.crashActualLRPArgsForCall, struct {
		key          *models.ActualLRPKey
		instanceKey  *models.ActualLRPInstanceKey
		errorMessage string
	}{key, instanceKey, errorMessage})
	fake.crashActualLRPMutex.Unlock()
	if fake.CrashActualLRPStub != nil {
		return fake.CrashActualLRPStub(key, instanceKey, errorMessage)
	} else {
		return fake.crashActualLRPReturns.result1
	}
}

func (fake *FakeClient) CrashActualLRPCallCount() int {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return len(fake.crashActualLRPArgsForCall)
}

func (fake *FakeClient) CrashActualLRPArgsForCall(i int) (*models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return fake.crashActualLRPArgsForCall[i].key, fake.crashActualLRPArgsForCall[i].instanceKey, fake.crashActualLRPArgsForCall[i].errorMessage
}

func (fake *FakeClient) CrashActualLRPReturns(result1 *models.Error) {
	fake.CrashActualLRPStub = nil
	fake.crashActualLRPReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) FailActualLRP(key *models.ActualLRPKey, errorMessage string) *models.Error {
	fake.failActualLRPMutex.Lock()
	fake.failActualLRPArgsForCall = append(fake.failActualLRPArgsForCall, struct {
		key          *models.ActualLRPKey
		errorMessage string
	}{key, errorMessage})
	fake.failActualLRPMutex.Unlock()
	if fake.FailActualLRPStub != nil {
		return fake.FailActualLRPStub(key, errorMessage)
	} else {
		return fake.failActualLRPReturns.result1
	}
}

func (fake *FakeClient) FailActualLRPCallCount() int {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return len(fake.failActualLRPArgsForCall)
}

func (fake *FakeClient) FailActualLRPArgsForCall(i int) (*models.ActualLRPKey, string) {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return fake.failActualLRPArgsForCall[i].key, fake.failActualLRPArgsForCall[i].errorMessage
}

func (fake *FakeClient) FailActualLRPReturns(result1 *models.Error) {
	fake.FailActualLRPStub = nil
	fake.failActualLRPReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) RemoveActualLRP(processGuid string, index int) *models.Error {
	fake.removeActualLRPMutex.Lock()
	fake.removeActualLRPArgsForCall = append(fake.removeActualLRPArgsForCall, struct {
		processGuid string
		index       int
	}{processGuid, index})
	fake.removeActualLRPMutex.Unlock()
	if fake.RemoveActualLRPStub != nil {
		return fake.RemoveActualLRPStub(processGuid, index)
	} else {
		return fake.removeActualLRPReturns.result1
	}
}

func (fake *FakeClient) RemoveActualLRPCallCount() int {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return len(fake.removeActualLRPArgsForCall)
}

func (fake *FakeClient) RemoveActualLRPArgsForCall(i int) (string, int) {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return fake.removeActualLRPArgsForCall[i].processGuid, fake.removeActualLRPArgsForCall[i].index
}

func (fake *FakeClient) RemoveActualLRPReturns(result1 *models.Error) {
	fake.RemoveActualLRPStub = nil
	fake.removeActualLRPReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) RetireActualLRP(key *models.ActualLRPKey) *models.Error {
	fake.retireActualLRPMutex.Lock()
	fake.retireActualLRPArgsForCall = append(fake.retireActualLRPArgsForCall, struct {
		key *models.ActualLRPKey
	}{key})
	fake.retireActualLRPMutex.Unlock()
	if fake.RetireActualLRPStub != nil {
		return fake.RetireActualLRPStub(key)
	} else {
		return fake.retireActualLRPReturns.result1
	}
}

func (fake *FakeClient) RetireActualLRPCallCount() int {
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	return len(fake.retireActualLRPArgsForCall)
}

func (fake *FakeClient) RetireActualLRPArgsForCall(i int) *models.ActualLRPKey {
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	return fake.retireActualLRPArgsForCall[i].key
}

func (fake *FakeClient) RetireActualLRPReturns(result1 *models.Error) {
	fake.RetireActualLRPStub = nil
	fake.retireActualLRPReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) EvacuateClaimedActualLRP(arg1 *models.ActualLRPKey, arg2 *models.ActualLRPInstanceKey) (bool, *models.Error) {
	fake.evacuateClaimedActualLRPMutex.Lock()
	fake.evacuateClaimedActualLRPArgsForCall = append(fake.evacuateClaimedActualLRPArgsForCall, struct {
		arg1 *models.ActualLRPKey
		arg2 *models.ActualLRPInstanceKey
	}{arg1, arg2})
	fake.evacuateClaimedActualLRPMutex.Unlock()
	if fake.EvacuateClaimedActualLRPStub != nil {
		return fake.EvacuateClaimedActualLRPStub(arg1, arg2)
	} else {
		return fake.evacuateClaimedActualLRPReturns.result1, fake.evacuateClaimedActualLRPReturns.result2
	}
}

func (fake *FakeClient) EvacuateClaimedActualLRPCallCount() int {
	fake.evacuateClaimedActualLRPMutex.RLock()
	defer fake.evacuateClaimedActualLRPMutex.RUnlock()
	return len(fake.evacuateClaimedActualLRPArgsForCall)
}

func (fake *FakeClient) EvacuateClaimedActualLRPArgsForCall(i int) (*models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.evacuateClaimedActualLRPMutex.RLock()
	defer fake.evacuateClaimedActualLRPMutex.RUnlock()
	return fake.evacuateClaimedActualLRPArgsForCall[i].arg1, fake.evacuateClaimedActualLRPArgsForCall[i].arg2
}

func (fake *FakeClient) EvacuateClaimedActualLRPReturns(result1 bool, result2 *models.Error) {
	fake.EvacuateClaimedActualLRPStub = nil
	fake.evacuateClaimedActualLRPReturns = struct {
		result1 bool
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) EvacuateRunningActualLRP(arg1 *models.ActualLRPKey, arg2 *models.ActualLRPInstanceKey, arg3 *models.ActualLRPNetInfo, arg4 uint64) (bool, *models.Error) {
	fake.evacuateRunningActualLRPMutex.Lock()
	fake.evacuateRunningActualLRPArgsForCall = append(fake.evacuateRunningActualLRPArgsForCall, struct {
		arg1 *models.ActualLRPKey
		arg2 *models.ActualLRPInstanceKey
		arg3 *models.ActualLRPNetInfo
		arg4 uint64
	}{arg1, arg2, arg3, arg4})
	fake.evacuateRunningActualLRPMutex.Unlock()
	if fake.EvacuateRunningActualLRPStub != nil {
		return fake.EvacuateRunningActualLRPStub(arg1, arg2, arg3, arg4)
	} else {
		return fake.evacuateRunningActualLRPReturns.result1, fake.evacuateRunningActualLRPReturns.result2
	}
}

func (fake *FakeClient) EvacuateRunningActualLRPCallCount() int {
	fake.evacuateRunningActualLRPMutex.RLock()
	defer fake.evacuateRunningActualLRPMutex.RUnlock()
	return len(fake.evacuateRunningActualLRPArgsForCall)
}

func (fake *FakeClient) EvacuateRunningActualLRPArgsForCall(i int) (*models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo, uint64) {
	fake.evacuateRunningActualLRPMutex.RLock()
	defer fake.evacuateRunningActualLRPMutex.RUnlock()
	return fake.evacuateRunningActualLRPArgsForCall[i].arg1, fake.evacuateRunningActualLRPArgsForCall[i].arg2, fake.evacuateRunningActualLRPArgsForCall[i].arg3, fake.evacuateRunningActualLRPArgsForCall[i].arg4
}

func (fake *FakeClient) EvacuateRunningActualLRPReturns(result1 bool, result2 *models.Error) {
	fake.EvacuateRunningActualLRPStub = nil
	fake.evacuateRunningActualLRPReturns = struct {
		result1 bool
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) EvacuateStoppedActualLRP(arg1 *models.ActualLRPKey, arg2 *models.ActualLRPInstanceKey) (bool, *models.Error) {
	fake.evacuateStoppedActualLRPMutex.Lock()
	fake.evacuateStoppedActualLRPArgsForCall = append(fake.evacuateStoppedActualLRPArgsForCall, struct {
		arg1 *models.ActualLRPKey
		arg2 *models.ActualLRPInstanceKey
	}{arg1, arg2})
	fake.evacuateStoppedActualLRPMutex.Unlock()
	if fake.EvacuateStoppedActualLRPStub != nil {
		return fake.EvacuateStoppedActualLRPStub(arg1, arg2)
	} else {
		return fake.evacuateStoppedActualLRPReturns.result1, fake.evacuateStoppedActualLRPReturns.result2
	}
}

func (fake *FakeClient) EvacuateStoppedActualLRPCallCount() int {
	fake.evacuateStoppedActualLRPMutex.RLock()
	defer fake.evacuateStoppedActualLRPMutex.RUnlock()
	return len(fake.evacuateStoppedActualLRPArgsForCall)
}

func (fake *FakeClient) EvacuateStoppedActualLRPArgsForCall(i int) (*models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.evacuateStoppedActualLRPMutex.RLock()
	defer fake.evacuateStoppedActualLRPMutex.RUnlock()
	return fake.evacuateStoppedActualLRPArgsForCall[i].arg1, fake.evacuateStoppedActualLRPArgsForCall[i].arg2
}

func (fake *FakeClient) EvacuateStoppedActualLRPReturns(result1 bool, result2 *models.Error) {
	fake.EvacuateStoppedActualLRPStub = nil
	fake.evacuateStoppedActualLRPReturns = struct {
		result1 bool
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) EvacuateCrashedActualLRP(arg1 *models.ActualLRPKey, arg2 *models.ActualLRPInstanceKey, arg3 string) (bool, *models.Error) {
	fake.evacuateCrashedActualLRPMutex.Lock()
	fake.evacuateCrashedActualLRPArgsForCall = append(fake.evacuateCrashedActualLRPArgsForCall, struct {
		arg1 *models.ActualLRPKey
		arg2 *models.ActualLRPInstanceKey
		arg3 string
	}{arg1, arg2, arg3})
	fake.evacuateCrashedActualLRPMutex.Unlock()
	if fake.EvacuateCrashedActualLRPStub != nil {
		return fake.EvacuateCrashedActualLRPStub(arg1, arg2, arg3)
	} else {
		return fake.evacuateCrashedActualLRPReturns.result1, fake.evacuateCrashedActualLRPReturns.result2
	}
}

func (fake *FakeClient) EvacuateCrashedActualLRPCallCount() int {
	fake.evacuateCrashedActualLRPMutex.RLock()
	defer fake.evacuateCrashedActualLRPMutex.RUnlock()
	return len(fake.evacuateCrashedActualLRPArgsForCall)
}

func (fake *FakeClient) EvacuateCrashedActualLRPArgsForCall(i int) (*models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.evacuateCrashedActualLRPMutex.RLock()
	defer fake.evacuateCrashedActualLRPMutex.RUnlock()
	return fake.evacuateCrashedActualLRPArgsForCall[i].arg1, fake.evacuateCrashedActualLRPArgsForCall[i].arg2, fake.evacuateCrashedActualLRPArgsForCall[i].arg3
}

func (fake *FakeClient) EvacuateCrashedActualLRPReturns(result1 bool, result2 *models.Error) {
	fake.EvacuateCrashedActualLRPStub = nil
	fake.evacuateCrashedActualLRPReturns = struct {
		result1 bool
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) RemoveEvacuatingActualLRP(arg1 *models.ActualLRPKey, arg2 *models.ActualLRPInstanceKey) *models.Error {
	fake.removeEvacuatingActualLRPMutex.Lock()
	fake.removeEvacuatingActualLRPArgsForCall = append(fake.removeEvacuatingActualLRPArgsForCall, struct {
		arg1 *models.ActualLRPKey
		arg2 *models.ActualLRPInstanceKey
	}{arg1, arg2})
	fake.removeEvacuatingActualLRPMutex.Unlock()
	if fake.RemoveEvacuatingActualLRPStub != nil {
		return fake.RemoveEvacuatingActualLRPStub(arg1, arg2)
	} else {
		return fake.removeEvacuatingActualLRPReturns.result1
	}
}

func (fake *FakeClient) RemoveEvacuatingActualLRPCallCount() int {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	return len(fake.removeEvacuatingActualLRPArgsForCall)
}

func (fake *FakeClient) RemoveEvacuatingActualLRPArgsForCall(i int) (*models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	return fake.removeEvacuatingActualLRPArgsForCall[i].arg1, fake.removeEvacuatingActualLRPArgsForCall[i].arg2
}

func (fake *FakeClient) RemoveEvacuatingActualLRPReturns(result1 *models.Error) {
	fake.RemoveEvacuatingActualLRPStub = nil
	fake.removeEvacuatingActualLRPReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) DesiredLRPs(arg1 models.DesiredLRPFilter) ([]*models.DesiredLRP, *models.Error) {
	fake.desiredLRPsMutex.Lock()
	fake.desiredLRPsArgsForCall = append(fake.desiredLRPsArgsForCall, struct {
		arg1 models.DesiredLRPFilter
	}{arg1})
	fake.desiredLRPsMutex.Unlock()
	if fake.DesiredLRPsStub != nil {
		return fake.DesiredLRPsStub(arg1)
	} else {
		return fake.desiredLRPsReturns.result1, fake.desiredLRPsReturns.result2
	}
}

func (fake *FakeClient) DesiredLRPsCallCount() int {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	return len(fake.desiredLRPsArgsForCall)
}

func (fake *FakeClient) DesiredLRPsArgsForCall(i int) models.DesiredLRPFilter {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	return fake.desiredLRPsArgsForCall[i].arg1
}

func (fake *FakeClient) DesiredLRPsReturns(result1 []*models.DesiredLRP, result2 *models.Error) {
	fake.DesiredLRPsStub = nil
	fake.desiredLRPsReturns = struct {
		result1 []*models.DesiredLRP
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) DesiredLRPByProcessGuid(processGuid string) (*models.DesiredLRP, *models.Error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	fake.desiredLRPByProcessGuidArgsForCall = append(fake.desiredLRPByProcessGuidArgsForCall, struct {
		processGuid string
	}{processGuid})
	fake.desiredLRPByProcessGuidMutex.Unlock()
	if fake.DesiredLRPByProcessGuidStub != nil {
		return fake.DesiredLRPByProcessGuidStub(processGuid)
	} else {
		return fake.desiredLRPByProcessGuidReturns.result1, fake.desiredLRPByProcessGuidReturns.result2
	}
}

func (fake *FakeClient) DesiredLRPByProcessGuidCallCount() int {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	return len(fake.desiredLRPByProcessGuidArgsForCall)
}

func (fake *FakeClient) DesiredLRPByProcessGuidArgsForCall(i int) string {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	return fake.desiredLRPByProcessGuidArgsForCall[i].processGuid
}

func (fake *FakeClient) DesiredLRPByProcessGuidReturns(result1 *models.DesiredLRP, result2 *models.Error) {
	fake.DesiredLRPByProcessGuidStub = nil
	fake.desiredLRPByProcessGuidReturns = struct {
		result1 *models.DesiredLRP
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) DesireLRP(arg1 *models.DesiredLRP) *models.Error {
	fake.desireLRPMutex.Lock()
	fake.desireLRPArgsForCall = append(fake.desireLRPArgsForCall, struct {
		arg1 *models.DesiredLRP
	}{arg1})
	fake.desireLRPMutex.Unlock()
	if fake.DesireLRPStub != nil {
		return fake.DesireLRPStub(arg1)
	} else {
		return fake.desireLRPReturns.result1
	}
}

func (fake *FakeClient) DesireLRPCallCount() int {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	return len(fake.desireLRPArgsForCall)
}

func (fake *FakeClient) DesireLRPArgsForCall(i int) *models.DesiredLRP {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	return fake.desireLRPArgsForCall[i].arg1
}

func (fake *FakeClient) DesireLRPReturns(result1 *models.Error) {
	fake.DesireLRPStub = nil
	fake.desireLRPReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) UpdateDesiredLRP(processGuid string, update *models.DesiredLRPUpdate) *models.Error {
	fake.updateDesiredLRPMutex.Lock()
	fake.updateDesiredLRPArgsForCall = append(fake.updateDesiredLRPArgsForCall, struct {
		processGuid string
		update      *models.DesiredLRPUpdate
	}{processGuid, update})
	fake.updateDesiredLRPMutex.Unlock()
	if fake.UpdateDesiredLRPStub != nil {
		return fake.UpdateDesiredLRPStub(processGuid, update)
	} else {
		return fake.updateDesiredLRPReturns.result1
	}
}

func (fake *FakeClient) UpdateDesiredLRPCallCount() int {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	return len(fake.updateDesiredLRPArgsForCall)
}

func (fake *FakeClient) UpdateDesiredLRPArgsForCall(i int) (string, *models.DesiredLRPUpdate) {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	return fake.updateDesiredLRPArgsForCall[i].processGuid, fake.updateDesiredLRPArgsForCall[i].update
}

func (fake *FakeClient) UpdateDesiredLRPReturns(result1 *models.Error) {
	fake.UpdateDesiredLRPStub = nil
	fake.updateDesiredLRPReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) RemoveDesiredLRP(processGuid string) *models.Error {
	fake.removeDesiredLRPMutex.Lock()
	fake.removeDesiredLRPArgsForCall = append(fake.removeDesiredLRPArgsForCall, struct {
		processGuid string
	}{processGuid})
	fake.removeDesiredLRPMutex.Unlock()
	if fake.RemoveDesiredLRPStub != nil {
		return fake.RemoveDesiredLRPStub(processGuid)
	} else {
		return fake.removeDesiredLRPReturns.result1
	}
}

func (fake *FakeClient) RemoveDesiredLRPCallCount() int {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	return len(fake.removeDesiredLRPArgsForCall)
}

func (fake *FakeClient) RemoveDesiredLRPArgsForCall(i int) string {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	return fake.removeDesiredLRPArgsForCall[i].processGuid
}

func (fake *FakeClient) RemoveDesiredLRPReturns(result1 *models.Error) {
	fake.RemoveDesiredLRPStub = nil
	fake.removeDesiredLRPReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) ConvergeLRPs() *models.Error {
	fake.convergeLRPsMutex.Lock()
	fake.convergeLRPsArgsForCall = append(fake.convergeLRPsArgsForCall, struct{}{})
	fake.convergeLRPsMutex.Unlock()
	if fake.ConvergeLRPsStub != nil {
		return fake.ConvergeLRPsStub()
	} else {
		return fake.convergeLRPsReturns.result1
	}
}

func (fake *FakeClient) ConvergeLRPsCallCount() int {
	fake.convergeLRPsMutex.RLock()
	defer fake.convergeLRPsMutex.RUnlock()
	return len(fake.convergeLRPsArgsForCall)
}

func (fake *FakeClient) ConvergeLRPsReturns(result1 *models.Error) {
	fake.ConvergeLRPsStub = nil
	fake.convergeLRPsReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) Tasks() ([]*models.Task, *models.Error) {
	fake.tasksMutex.Lock()
	fake.tasksArgsForCall = append(fake.tasksArgsForCall, struct{}{})
	fake.tasksMutex.Unlock()
	if fake.TasksStub != nil {
		return fake.TasksStub()
	} else {
		return fake.tasksReturns.result1, fake.tasksReturns.result2
	}
}

func (fake *FakeClient) TasksCallCount() int {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return len(fake.tasksArgsForCall)
}

func (fake *FakeClient) TasksReturns(result1 []*models.Task, result2 *models.Error) {
	fake.TasksStub = nil
	fake.tasksReturns = struct {
		result1 []*models.Task
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) TasksByDomain(domain string) ([]*models.Task, *models.Error) {
	fake.tasksByDomainMutex.Lock()
	fake.tasksByDomainArgsForCall = append(fake.tasksByDomainArgsForCall, struct {
		domain string
	}{domain})
	fake.tasksByDomainMutex.Unlock()
	if fake.TasksByDomainStub != nil {
		return fake.TasksByDomainStub(domain)
	} else {
		return fake.tasksByDomainReturns.result1, fake.tasksByDomainReturns.result2
	}
}

func (fake *FakeClient) TasksByDomainCallCount() int {
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	return len(fake.tasksByDomainArgsForCall)
}

func (fake *FakeClient) TasksByDomainArgsForCall(i int) string {
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	return fake.tasksByDomainArgsForCall[i].domain
}

func (fake *FakeClient) TasksByDomainReturns(result1 []*models.Task, result2 *models.Error) {
	fake.TasksByDomainStub = nil
	fake.tasksByDomainReturns = struct {
		result1 []*models.Task
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) TasksByCellID(cellId string) ([]*models.Task, *models.Error) {
	fake.tasksByCellIDMutex.Lock()
	fake.tasksByCellIDArgsForCall = append(fake.tasksByCellIDArgsForCall, struct {
		cellId string
	}{cellId})
	fake.tasksByCellIDMutex.Unlock()
	if fake.TasksByCellIDStub != nil {
		return fake.TasksByCellIDStub(cellId)
	} else {
		return fake.tasksByCellIDReturns.result1, fake.tasksByCellIDReturns.result2
	}
}

func (fake *FakeClient) TasksByCellIDCallCount() int {
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	return len(fake.tasksByCellIDArgsForCall)
}

func (fake *FakeClient) TasksByCellIDArgsForCall(i int) string {
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	return fake.tasksByCellIDArgsForCall[i].cellId
}

func (fake *FakeClient) TasksByCellIDReturns(result1 []*models.Task, result2 *models.Error) {
	fake.TasksByCellIDStub = nil
	fake.tasksByCellIDReturns = struct {
		result1 []*models.Task
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) TaskByGuid(guid string) (*models.Task, *models.Error) {
	fake.taskByGuidMutex.Lock()
	fake.taskByGuidArgsForCall = append(fake.taskByGuidArgsForCall, struct {
		guid string
	}{guid})
	fake.taskByGuidMutex.Unlock()
	if fake.TaskByGuidStub != nil {
		return fake.TaskByGuidStub(guid)
	} else {
		return fake.taskByGuidReturns.result1, fake.taskByGuidReturns.result2
	}
}

func (fake *FakeClient) TaskByGuidCallCount() int {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return len(fake.taskByGuidArgsForCall)
}

func (fake *FakeClient) TaskByGuidArgsForCall(i int) string {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return fake.taskByGuidArgsForCall[i].guid
}

func (fake *FakeClient) TaskByGuidReturns(result1 *models.Task, result2 *models.Error) {
	fake.TaskByGuidStub = nil
	fake.taskByGuidReturns = struct {
		result1 *models.Task
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) DesireTask(guid string, domain string, def *models.TaskDefinition) *models.Error {
	fake.desireTaskMutex.Lock()
	fake.desireTaskArgsForCall = append(fake.desireTaskArgsForCall, struct {
		guid   string
		domain string
		def    *models.TaskDefinition
	}{guid, domain, def})
	fake.desireTaskMutex.Unlock()
	if fake.DesireTaskStub != nil {
		return fake.DesireTaskStub(guid, domain, def)
	} else {
		return fake.desireTaskReturns.result1
	}
}

func (fake *FakeClient) DesireTaskCallCount() int {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return len(fake.desireTaskArgsForCall)
}

func (fake *FakeClient) DesireTaskArgsForCall(i int) (string, string, *models.TaskDefinition) {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return fake.desireTaskArgsForCall[i].guid, fake.desireTaskArgsForCall[i].domain, fake.desireTaskArgsForCall[i].def
}

func (fake *FakeClient) DesireTaskReturns(result1 *models.Error) {
	fake.DesireTaskStub = nil
	fake.desireTaskReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) CancelTask(taskGuid string) *models.Error {
	fake.cancelTaskMutex.Lock()
	fake.cancelTaskArgsForCall = append(fake.cancelTaskArgsForCall, struct {
		taskGuid string
	}{taskGuid})
	fake.cancelTaskMutex.Unlock()
	if fake.CancelTaskStub != nil {
		return fake.CancelTaskStub(taskGuid)
	} else {
		return fake.cancelTaskReturns.result1
	}
}

func (fake *FakeClient) CancelTaskCallCount() int {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return len(fake.cancelTaskArgsForCall)
}

func (fake *FakeClient) CancelTaskArgsForCall(i int) string {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return fake.cancelTaskArgsForCall[i].taskGuid
}

func (fake *FakeClient) CancelTaskReturns(result1 *models.Error) {
	fake.CancelTaskStub = nil
	fake.cancelTaskReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) FailTask(taskGuid string, failureReason string) *models.Error {
	fake.failTaskMutex.Lock()
	fake.failTaskArgsForCall = append(fake.failTaskArgsForCall, struct {
		taskGuid      string
		failureReason string
	}{taskGuid, failureReason})
	fake.failTaskMutex.Unlock()
	if fake.FailTaskStub != nil {
		return fake.FailTaskStub(taskGuid, failureReason)
	} else {
		return fake.failTaskReturns.result1
	}
}

func (fake *FakeClient) FailTaskCallCount() int {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return len(fake.failTaskArgsForCall)
}

func (fake *FakeClient) FailTaskArgsForCall(i int) (string, string) {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return fake.failTaskArgsForCall[i].taskGuid, fake.failTaskArgsForCall[i].failureReason
}

func (fake *FakeClient) FailTaskReturns(result1 *models.Error) {
	fake.FailTaskStub = nil
	fake.failTaskReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) CompleteTask(taskGuid string, cellId string, failed bool, failureReason string, result string) *models.Error {
	fake.completeTaskMutex.Lock()
	fake.completeTaskArgsForCall = append(fake.completeTaskArgsForCall, struct {
		taskGuid      string
		cellId        string
		failed        bool
		failureReason string
		result        string
	}{taskGuid, cellId, failed, failureReason, result})
	fake.completeTaskMutex.Unlock()
	if fake.CompleteTaskStub != nil {
		return fake.CompleteTaskStub(taskGuid, cellId, failed, failureReason, result)
	} else {
		return fake.completeTaskReturns.result1
	}
}

func (fake *FakeClient) CompleteTaskCallCount() int {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return len(fake.completeTaskArgsForCall)
}

func (fake *FakeClient) CompleteTaskArgsForCall(i int) (string, string, bool, string, string) {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return fake.completeTaskArgsForCall[i].taskGuid, fake.completeTaskArgsForCall[i].cellId, fake.completeTaskArgsForCall[i].failed, fake.completeTaskArgsForCall[i].failureReason, fake.completeTaskArgsForCall[i].result
}

func (fake *FakeClient) CompleteTaskReturns(result1 *models.Error) {
	fake.CompleteTaskStub = nil
	fake.completeTaskReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) ResolvingTask(taskGuid string) *models.Error {
	fake.resolvingTaskMutex.Lock()
	fake.resolvingTaskArgsForCall = append(fake.resolvingTaskArgsForCall, struct {
		taskGuid string
	}{taskGuid})
	fake.resolvingTaskMutex.Unlock()
	if fake.ResolvingTaskStub != nil {
		return fake.ResolvingTaskStub(taskGuid)
	} else {
		return fake.resolvingTaskReturns.result1
	}
}

func (fake *FakeClient) ResolvingTaskCallCount() int {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return len(fake.resolvingTaskArgsForCall)
}

func (fake *FakeClient) ResolvingTaskArgsForCall(i int) string {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return fake.resolvingTaskArgsForCall[i].taskGuid
}

func (fake *FakeClient) ResolvingTaskReturns(result1 *models.Error) {
	fake.ResolvingTaskStub = nil
	fake.resolvingTaskReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) DeleteTask(taskGuid string) *models.Error {
	fake.deleteTaskMutex.Lock()
	fake.deleteTaskArgsForCall = append(fake.deleteTaskArgsForCall, struct {
		taskGuid string
	}{taskGuid})
	fake.deleteTaskMutex.Unlock()
	if fake.DeleteTaskStub != nil {
		return fake.DeleteTaskStub(taskGuid)
	} else {
		return fake.deleteTaskReturns.result1
	}
}

func (fake *FakeClient) DeleteTaskCallCount() int {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return len(fake.deleteTaskArgsForCall)
}

func (fake *FakeClient) DeleteTaskArgsForCall(i int) string {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return fake.deleteTaskArgsForCall[i].taskGuid
}

func (fake *FakeClient) DeleteTaskReturns(result1 *models.Error) {
	fake.DeleteTaskStub = nil
	fake.deleteTaskReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) ConvergeTasks(kickTaskDuration time.Duration, expirePendingTaskDuration time.Duration, expireCompletedTaskDuration time.Duration) *models.Error {
	fake.convergeTasksMutex.Lock()
	fake.convergeTasksArgsForCall = append(fake.convergeTasksArgsForCall, struct {
		kickTaskDuration            time.Duration
		expirePendingTaskDuration   time.Duration
		expireCompletedTaskDuration time.Duration
	}{kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration})
	fake.convergeTasksMutex.Unlock()
	if fake.ConvergeTasksStub != nil {
		return fake.ConvergeTasksStub(kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration)
	} else {
		return fake.convergeTasksReturns.result1
	}
}

func (fake *FakeClient) ConvergeTasksCallCount() int {
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	return len(fake.convergeTasksArgsForCall)
}

func (fake *FakeClient) ConvergeTasksArgsForCall(i int) (time.Duration, time.Duration, time.Duration) {
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	return fake.convergeTasksArgsForCall[i].kickTaskDuration, fake.convergeTasksArgsForCall[i].expirePendingTaskDuration, fake.convergeTasksArgsForCall[i].expireCompletedTaskDuration
}

func (fake *FakeClient) ConvergeTasksReturns(result1 *models.Error) {
	fake.ConvergeTasksStub = nil
	fake.convergeTasksReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeClient) SubscribeToEvents() (events.EventSource, *models.Error) {
	fake.subscribeToEventsMutex.Lock()
	fake.subscribeToEventsArgsForCall = append(fake.subscribeToEventsArgsForCall, struct{}{})
	fake.subscribeToEventsMutex.Unlock()
	if fake.SubscribeToEventsStub != nil {
		return fake.SubscribeToEventsStub()
	} else {
		return fake.subscribeToEventsReturns.result1, fake.subscribeToEventsReturns.result2
	}
}

func (fake *FakeClient) SubscribeToEventsCallCount() int {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	return len(fake.subscribeToEventsArgsForCall)
}

func (fake *FakeClient) SubscribeToEventsReturns(result1 events.EventSource, result2 *models.Error) {
	fake.SubscribeToEventsStub = nil
	fake.subscribeToEventsReturns = struct {
		result1 events.EventSource
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeClient) StartTask(taskGuid string, cellID string) (bool, *models.Error) {
	fake.startTaskMutex.Lock()
	fake.startTaskArgsForCall = append(fake.startTaskArgsForCall, struct {
		taskGuid string
		cellID   string
	}{taskGuid, cellID})
	fake.startTaskMutex.Unlock()
	if fake.StartTaskStub != nil {
		return fake.StartTaskStub(taskGuid, cellID)
	} else {
		return fake.startTaskReturns.result1, fake.startTaskReturns.result2
	}
}

func (fake *FakeClient) StartTaskCallCount() int {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return len(fake.startTaskArgsForCall)
}

func (fake *FakeClient) StartTaskArgsForCall(i int) (string, string) {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return fake.startTaskArgsForCall[i].taskGuid, fake.startTaskArgsForCall[i].cellID
}

func (fake *FakeClient) StartTaskReturns(result1 bool, result2 *models.Error) {
	fake.StartTaskStub = nil
	fake.startTaskReturns = struct {
		result1 bool
		result2 *models.Error
	}{result1, result2}
}

var _ bbs.Client = new(FakeClient)
