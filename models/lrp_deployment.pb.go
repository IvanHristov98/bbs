// Code generated by protoc-gen-gogo.
// source: lrp_deployment.proto
// DO NOT EDIT!

package models

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type LRPDeployment struct {
	ProcessGuid         string                    `protobuf:"bytes,1,opt,name=process_guid,json=processGuid" json:"process_guid"`
	Domain              string                    `protobuf:"bytes,2,opt,name=domain" json:"domain"`
	Instances           int32                     `protobuf:"varint,3,opt,name=instances" json:"instances"`
	Annotation          string                    `protobuf:"bytes,4,opt,name=annotation" json:"annotation"`
	Routes              *Routes                   `protobuf:"bytes,5,opt,name=routes,customtype=Routes" json:"routes,omitempty"`
	Definitions         map[string]*LRPDefinition `protobuf:"bytes,6,rep,name=definitions" json:"definitions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ActiveDefinitionId  string                    `protobuf:"bytes,7,opt,name=active_definition_id,json=activeDefinitionId" json:"active_definition_id"`
	HealthyDefinitionId string                    `protobuf:"bytes,8,opt,name=healthy_definition_id,json=healthyDefinitionId" json:"healthy_definition_id"`
	ModificationTag     *ModificationTag          `protobuf:"bytes,9,opt,name=modification_tag,json=modificationTag" json:"modification_tag,omitempty"`
}

func (m *LRPDeployment) Reset()                    { *m = LRPDeployment{} }
func (*LRPDeployment) ProtoMessage()               {}
func (*LRPDeployment) Descriptor() ([]byte, []int) { return fileDescriptorLrpDeployment, []int{0} }

func (m *LRPDeployment) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}

func (m *LRPDeployment) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *LRPDeployment) GetInstances() int32 {
	if m != nil {
		return m.Instances
	}
	return 0
}

func (m *LRPDeployment) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	return ""
}

func (m *LRPDeployment) GetDefinitions() map[string]*LRPDefinition {
	if m != nil {
		return m.Definitions
	}
	return nil
}

func (m *LRPDeployment) GetActiveDefinitionId() string {
	if m != nil {
		return m.ActiveDefinitionId
	}
	return ""
}

func (m *LRPDeployment) GetHealthyDefinitionId() string {
	if m != nil {
		return m.HealthyDefinitionId
	}
	return ""
}

func (m *LRPDeployment) GetModificationTag() *ModificationTag {
	if m != nil {
		return m.ModificationTag
	}
	return nil
}

type LRPDeploymentCreation struct {
	ProcessGuid  string         `protobuf:"bytes,1,opt,name=process_guid,json=processGuid" json:"process_guid"`
	Domain       string         `protobuf:"bytes,2,opt,name=domain" json:"domain"`
	Instances    int32          `protobuf:"varint,3,opt,name=instances" json:"instances"`
	Annotation   string         `protobuf:"bytes,4,opt,name=annotation" json:"annotation"`
	Routes       *Routes        `protobuf:"bytes,5,opt,name=routes,customtype=Routes" json:"routes,omitempty"`
	DefinitionId string         `protobuf:"bytes,6,opt,name=definition_id,json=definitionId" json:"definition_id"`
	Definition   *LRPDefinition `protobuf:"bytes,7,opt,name=definition" json:"definition,omitempty"`
}

func (m *LRPDeploymentCreation) Reset()      { *m = LRPDeploymentCreation{} }
func (*LRPDeploymentCreation) ProtoMessage() {}
func (*LRPDeploymentCreation) Descriptor() ([]byte, []int) {
	return fileDescriptorLrpDeployment, []int{1}
}

func (m *LRPDeploymentCreation) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}

func (m *LRPDeploymentCreation) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *LRPDeploymentCreation) GetInstances() int32 {
	if m != nil {
		return m.Instances
	}
	return 0
}

func (m *LRPDeploymentCreation) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	return ""
}

func (m *LRPDeploymentCreation) GetDefinitionId() string {
	if m != nil {
		return m.DefinitionId
	}
	return ""
}

func (m *LRPDeploymentCreation) GetDefinition() *LRPDefinition {
	if m != nil {
		return m.Definition
	}
	return nil
}

type LRPDeploymentUpdate struct {
	Instances    *int32         `protobuf:"varint,1,opt,name=instances" json:"instances,omitempty"`
	Annotation   *string        `protobuf:"bytes,2,opt,name=annotation" json:"annotation,omitempty"`
	Routes       *Routes        `protobuf:"bytes,3,opt,name=routes,customtype=Routes" json:"routes,omitempty"`
	DefinitionId *string        `protobuf:"bytes,4,opt,name=definition_id,json=definitionId" json:"definition_id,omitempty"`
	Definition   *LRPDefinition `protobuf:"bytes,5,opt,name=definition" json:"definition,omitempty"`
}

func (m *LRPDeploymentUpdate) Reset()                    { *m = LRPDeploymentUpdate{} }
func (*LRPDeploymentUpdate) ProtoMessage()               {}
func (*LRPDeploymentUpdate) Descriptor() ([]byte, []int) { return fileDescriptorLrpDeployment, []int{2} }

func (m *LRPDeploymentUpdate) GetInstances() int32 {
	if m != nil && m.Instances != nil {
		return *m.Instances
	}
	return 0
}

func (m *LRPDeploymentUpdate) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *LRPDeploymentUpdate) GetDefinitionId() string {
	if m != nil && m.DefinitionId != nil {
		return *m.DefinitionId
	}
	return ""
}

func (m *LRPDeploymentUpdate) GetDefinition() *LRPDefinition {
	if m != nil {
		return m.Definition
	}
	return nil
}

type LRPDefinition struct {
	DefinitionId                  string                 `protobuf:"bytes,1,opt,name=definition_id,json=definitionId" json:"definition_id"`
	RootFs                        string                 `protobuf:"bytes,2,opt,name=root_fs,json=rootFs" json:"rootfs"`
	EnvironmentVariables          []*EnvironmentVariable `protobuf:"bytes,3,rep,name=environment_variables,json=environmentVariables" json:"env"`
	Setup                         *Action                `protobuf:"bytes,4,opt,name=setup" json:"setup,omitempty"`
	Action                        *Action                `protobuf:"bytes,5,opt,name=action" json:"action,omitempty"`
	StartTimeoutMs                int64                  `protobuf:"varint,6,opt,name=start_timeout_ms,json=startTimeoutMs" json:"start_timeout_ms"`
	DeprecatedStartTimeoutS       uint32                 `protobuf:"varint,7,opt,name=deprecated_start_timeout_s,json=deprecatedStartTimeoutS" json:"deprecated_timeout_ns,omitempty"`
	Monitor                       *Action                `protobuf:"bytes,8,opt,name=monitor" json:"monitor,omitempty"`
	DiskMb                        int32                  `protobuf:"varint,9,opt,name=disk_mb,json=diskMb" json:"disk_mb"`
	MemoryMb                      int32                  `protobuf:"varint,10,opt,name=memory_mb,json=memoryMb" json:"memory_mb"`
	CpuWeight                     uint32                 `protobuf:"varint,11,opt,name=cpu_weight,json=cpuWeight" json:"cpu_weight"`
	Privileged                    bool                   `protobuf:"varint,12,opt,name=privileged" json:"privileged"`
	Ports                         []uint32               `protobuf:"varint,13,rep,name=ports" json:"ports,omitempty"`
	LogSource                     string                 `protobuf:"bytes,14,opt,name=log_source,json=logSource" json:"log_source"`
	LogGuid                       string                 `protobuf:"bytes,15,opt,name=log_guid,json=logGuid" json:"log_guid"`
	MetricsGuid                   string                 `protobuf:"bytes,16,opt,name=metrics_guid,json=metricsGuid" json:"metrics_guid"`
	EgressRules                   []*SecurityGroupRule   `protobuf:"bytes,17,rep,name=egress_rules,json=egressRules" json:"egress_rules,omitempty"`
	CachedDependencies            []*CachedDependency    `protobuf:"bytes,18,rep,name=cached_dependencies,json=cachedDependencies" json:"cached_dependencies,omitempty"`
	LegacyDownloadUser            string                 `protobuf:"bytes,19,opt,name=legacy_download_user,json=legacyDownloadUser" json:"legacy_download_user,omitempty"`
	TrustedSystemCertificatesPath string                 `protobuf:"bytes,20,opt,name=trusted_system_certificates_path,json=trustedSystemCertificatesPath" json:"trusted_system_certificates_path,omitempty"`
	VolumePlacement               *VolumePlacement       `protobuf:"bytes,21,opt,name=volume_placement,json=volumePlacement" json:"volume_placement,omitempty"`
	VolumeMounts                  []*VolumeMount         `protobuf:"bytes,22,rep,name=volume_mounts,json=volumeMounts" json:"volume_mounts,omitempty"`
	Network                       *Network               `protobuf:"bytes,23,opt,name=network" json:"network,omitempty"`
	PlacementTags                 []string               `protobuf:"bytes,24,rep,name=placement_tags,json=placementTags" json:"placement_tags,omitempty"`
	MaxPids                       int32                  `protobuf:"varint,25,opt,name=max_pids,json=maxPids" json:"max_pids"`
	CertificateProperties         *CertificateProperties `protobuf:"bytes,26,opt,name=certificate_properties,json=certificateProperties" json:"certificate_properties,omitempty"`
	ImageUsername                 string                 `protobuf:"bytes,27,opt,name=image_username,json=imageUsername" json:"image_username,omitempty"`
	ImagePassword                 string                 `protobuf:"bytes,28,opt,name=image_password,json=imagePassword" json:"image_password,omitempty"`
	CheckDefinition               *CheckDefinition       `protobuf:"bytes,29,opt,name=check_definition,json=checkDefinition" json:"check_definition,omitempty"`
}

func (m *LRPDefinition) Reset()                    { *m = LRPDefinition{} }
func (*LRPDefinition) ProtoMessage()               {}
func (*LRPDefinition) Descriptor() ([]byte, []int) { return fileDescriptorLrpDeployment, []int{3} }

func (m *LRPDefinition) GetDefinitionId() string {
	if m != nil {
		return m.DefinitionId
	}
	return ""
}

func (m *LRPDefinition) GetRootFs() string {
	if m != nil {
		return m.RootFs
	}
	return ""
}

func (m *LRPDefinition) GetEnvironmentVariables() []*EnvironmentVariable {
	if m != nil {
		return m.EnvironmentVariables
	}
	return nil
}

func (m *LRPDefinition) GetSetup() *Action {
	if m != nil {
		return m.Setup
	}
	return nil
}

func (m *LRPDefinition) GetAction() *Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *LRPDefinition) GetStartTimeoutMs() int64 {
	if m != nil {
		return m.StartTimeoutMs
	}
	return 0
}

func (m *LRPDefinition) GetDeprecatedStartTimeoutS() uint32 {
	if m != nil {
		return m.DeprecatedStartTimeoutS
	}
	return 0
}

func (m *LRPDefinition) GetMonitor() *Action {
	if m != nil {
		return m.Monitor
	}
	return nil
}

func (m *LRPDefinition) GetDiskMb() int32 {
	if m != nil {
		return m.DiskMb
	}
	return 0
}

func (m *LRPDefinition) GetMemoryMb() int32 {
	if m != nil {
		return m.MemoryMb
	}
	return 0
}

func (m *LRPDefinition) GetCpuWeight() uint32 {
	if m != nil {
		return m.CpuWeight
	}
	return 0
}

func (m *LRPDefinition) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *LRPDefinition) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *LRPDefinition) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	return ""
}

func (m *LRPDefinition) GetLogGuid() string {
	if m != nil {
		return m.LogGuid
	}
	return ""
}

func (m *LRPDefinition) GetMetricsGuid() string {
	if m != nil {
		return m.MetricsGuid
	}
	return ""
}

func (m *LRPDefinition) GetEgressRules() []*SecurityGroupRule {
	if m != nil {
		return m.EgressRules
	}
	return nil
}

func (m *LRPDefinition) GetCachedDependencies() []*CachedDependency {
	if m != nil {
		return m.CachedDependencies
	}
	return nil
}

func (m *LRPDefinition) GetLegacyDownloadUser() string {
	if m != nil {
		return m.LegacyDownloadUser
	}
	return ""
}

func (m *LRPDefinition) GetTrustedSystemCertificatesPath() string {
	if m != nil {
		return m.TrustedSystemCertificatesPath
	}
	return ""
}

func (m *LRPDefinition) GetVolumePlacement() *VolumePlacement {
	if m != nil {
		return m.VolumePlacement
	}
	return nil
}

func (m *LRPDefinition) GetVolumeMounts() []*VolumeMount {
	if m != nil {
		return m.VolumeMounts
	}
	return nil
}

func (m *LRPDefinition) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *LRPDefinition) GetPlacementTags() []string {
	if m != nil {
		return m.PlacementTags
	}
	return nil
}

func (m *LRPDefinition) GetMaxPids() int32 {
	if m != nil {
		return m.MaxPids
	}
	return 0
}

func (m *LRPDefinition) GetCertificateProperties() *CertificateProperties {
	if m != nil {
		return m.CertificateProperties
	}
	return nil
}

func (m *LRPDefinition) GetImageUsername() string {
	if m != nil {
		return m.ImageUsername
	}
	return ""
}

func (m *LRPDefinition) GetImagePassword() string {
	if m != nil {
		return m.ImagePassword
	}
	return ""
}

func (m *LRPDefinition) GetCheckDefinition() *CheckDefinition {
	if m != nil {
		return m.CheckDefinition
	}
	return nil
}

func init() {
	proto.RegisterType((*LRPDeployment)(nil), "models.LRPDeployment")
	proto.RegisterType((*LRPDeploymentCreation)(nil), "models.LRPDeploymentCreation")
	proto.RegisterType((*LRPDeploymentUpdate)(nil), "models.LRPDeploymentUpdate")
	proto.RegisterType((*LRPDefinition)(nil), "models.LRPDefinition")
}
func (this *LRPDeployment) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LRPDeployment)
	if !ok {
		that2, ok := that.(LRPDeployment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.Instances != that1.Instances {
		return false
	}
	if this.Annotation != that1.Annotation {
		return false
	}
	if that1.Routes == nil {
		if this.Routes != nil {
			return false
		}
	} else if !this.Routes.Equal(*that1.Routes) {
		return false
	}
	if len(this.Definitions) != len(that1.Definitions) {
		return false
	}
	for i := range this.Definitions {
		if !this.Definitions[i].Equal(that1.Definitions[i]) {
			return false
		}
	}
	if this.ActiveDefinitionId != that1.ActiveDefinitionId {
		return false
	}
	if this.HealthyDefinitionId != that1.HealthyDefinitionId {
		return false
	}
	if !this.ModificationTag.Equal(that1.ModificationTag) {
		return false
	}
	return true
}
func (this *LRPDeploymentCreation) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LRPDeploymentCreation)
	if !ok {
		that2, ok := that.(LRPDeploymentCreation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.Instances != that1.Instances {
		return false
	}
	if this.Annotation != that1.Annotation {
		return false
	}
	if that1.Routes == nil {
		if this.Routes != nil {
			return false
		}
	} else if !this.Routes.Equal(*that1.Routes) {
		return false
	}
	if this.DefinitionId != that1.DefinitionId {
		return false
	}
	if !this.Definition.Equal(that1.Definition) {
		return false
	}
	return true
}
func (this *LRPDeploymentUpdate) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LRPDeploymentUpdate)
	if !ok {
		that2, ok := that.(LRPDeploymentUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Instances != nil && that1.Instances != nil {
		if *this.Instances != *that1.Instances {
			return false
		}
	} else if this.Instances != nil {
		return false
	} else if that1.Instances != nil {
		return false
	}
	if this.Annotation != nil && that1.Annotation != nil {
		if *this.Annotation != *that1.Annotation {
			return false
		}
	} else if this.Annotation != nil {
		return false
	} else if that1.Annotation != nil {
		return false
	}
	if that1.Routes == nil {
		if this.Routes != nil {
			return false
		}
	} else if !this.Routes.Equal(*that1.Routes) {
		return false
	}
	if this.DefinitionId != nil && that1.DefinitionId != nil {
		if *this.DefinitionId != *that1.DefinitionId {
			return false
		}
	} else if this.DefinitionId != nil {
		return false
	} else if that1.DefinitionId != nil {
		return false
	}
	if !this.Definition.Equal(that1.Definition) {
		return false
	}
	return true
}
func (this *LRPDefinition) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LRPDefinition)
	if !ok {
		that2, ok := that.(LRPDefinition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.DefinitionId != that1.DefinitionId {
		return false
	}
	if this.RootFs != that1.RootFs {
		return false
	}
	if len(this.EnvironmentVariables) != len(that1.EnvironmentVariables) {
		return false
	}
	for i := range this.EnvironmentVariables {
		if !this.EnvironmentVariables[i].Equal(that1.EnvironmentVariables[i]) {
			return false
		}
	}
	if !this.Setup.Equal(that1.Setup) {
		return false
	}
	if !this.Action.Equal(that1.Action) {
		return false
	}
	if this.StartTimeoutMs != that1.StartTimeoutMs {
		return false
	}
	if this.DeprecatedStartTimeoutS != that1.DeprecatedStartTimeoutS {
		return false
	}
	if !this.Monitor.Equal(that1.Monitor) {
		return false
	}
	if this.DiskMb != that1.DiskMb {
		return false
	}
	if this.MemoryMb != that1.MemoryMb {
		return false
	}
	if this.CpuWeight != that1.CpuWeight {
		return false
	}
	if this.Privileged != that1.Privileged {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	if this.LogGuid != that1.LogGuid {
		return false
	}
	if this.MetricsGuid != that1.MetricsGuid {
		return false
	}
	if len(this.EgressRules) != len(that1.EgressRules) {
		return false
	}
	for i := range this.EgressRules {
		if !this.EgressRules[i].Equal(that1.EgressRules[i]) {
			return false
		}
	}
	if len(this.CachedDependencies) != len(that1.CachedDependencies) {
		return false
	}
	for i := range this.CachedDependencies {
		if !this.CachedDependencies[i].Equal(that1.CachedDependencies[i]) {
			return false
		}
	}
	if this.LegacyDownloadUser != that1.LegacyDownloadUser {
		return false
	}
	if this.TrustedSystemCertificatesPath != that1.TrustedSystemCertificatesPath {
		return false
	}
	if !this.VolumePlacement.Equal(that1.VolumePlacement) {
		return false
	}
	if len(this.VolumeMounts) != len(that1.VolumeMounts) {
		return false
	}
	for i := range this.VolumeMounts {
		if !this.VolumeMounts[i].Equal(that1.VolumeMounts[i]) {
			return false
		}
	}
	if !this.Network.Equal(that1.Network) {
		return false
	}
	if len(this.PlacementTags) != len(that1.PlacementTags) {
		return false
	}
	for i := range this.PlacementTags {
		if this.PlacementTags[i] != that1.PlacementTags[i] {
			return false
		}
	}
	if this.MaxPids != that1.MaxPids {
		return false
	}
	if !this.CertificateProperties.Equal(that1.CertificateProperties) {
		return false
	}
	if this.ImageUsername != that1.ImageUsername {
		return false
	}
	if this.ImagePassword != that1.ImagePassword {
		return false
	}
	if !this.CheckDefinition.Equal(that1.CheckDefinition) {
		return false
	}
	return true
}
func (this *LRPDeployment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&models.LRPDeployment{")
	s = append(s, "ProcessGuid: "+fmt.Sprintf("%#v", this.ProcessGuid)+",\n")
	s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	s = append(s, "Instances: "+fmt.Sprintf("%#v", this.Instances)+",\n")
	s = append(s, "Annotation: "+fmt.Sprintf("%#v", this.Annotation)+",\n")
	if this.Routes != nil {
		s = append(s, "Routes: "+valueToGoStringLrpDeployment(this.Routes, "Routes")+",\n")
	}
	keysForDefinitions := make([]string, 0, len(this.Definitions))
	for k, _ := range this.Definitions {
		keysForDefinitions = append(keysForDefinitions, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDefinitions)
	mapStringForDefinitions := "map[string]*LRPDefinition{"
	for _, k := range keysForDefinitions {
		mapStringForDefinitions += fmt.Sprintf("%#v: %#v,", k, this.Definitions[k])
	}
	mapStringForDefinitions += "}"
	if this.Definitions != nil {
		s = append(s, "Definitions: "+mapStringForDefinitions+",\n")
	}
	s = append(s, "ActiveDefinitionId: "+fmt.Sprintf("%#v", this.ActiveDefinitionId)+",\n")
	s = append(s, "HealthyDefinitionId: "+fmt.Sprintf("%#v", this.HealthyDefinitionId)+",\n")
	if this.ModificationTag != nil {
		s = append(s, "ModificationTag: "+fmt.Sprintf("%#v", this.ModificationTag)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LRPDeploymentCreation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&models.LRPDeploymentCreation{")
	s = append(s, "ProcessGuid: "+fmt.Sprintf("%#v", this.ProcessGuid)+",\n")
	s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	s = append(s, "Instances: "+fmt.Sprintf("%#v", this.Instances)+",\n")
	s = append(s, "Annotation: "+fmt.Sprintf("%#v", this.Annotation)+",\n")
	if this.Routes != nil {
		s = append(s, "Routes: "+valueToGoStringLrpDeployment(this.Routes, "Routes")+",\n")
	}
	s = append(s, "DefinitionId: "+fmt.Sprintf("%#v", this.DefinitionId)+",\n")
	if this.Definition != nil {
		s = append(s, "Definition: "+fmt.Sprintf("%#v", this.Definition)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LRPDeploymentUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&models.LRPDeploymentUpdate{")
	if this.Instances != nil {
		s = append(s, "Instances: "+valueToGoStringLrpDeployment(this.Instances, "int32")+",\n")
	}
	if this.Annotation != nil {
		s = append(s, "Annotation: "+valueToGoStringLrpDeployment(this.Annotation, "string")+",\n")
	}
	if this.Routes != nil {
		s = append(s, "Routes: "+valueToGoStringLrpDeployment(this.Routes, "Routes")+",\n")
	}
	if this.DefinitionId != nil {
		s = append(s, "DefinitionId: "+valueToGoStringLrpDeployment(this.DefinitionId, "string")+",\n")
	}
	if this.Definition != nil {
		s = append(s, "Definition: "+fmt.Sprintf("%#v", this.Definition)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LRPDefinition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 33)
	s = append(s, "&models.LRPDefinition{")
	s = append(s, "DefinitionId: "+fmt.Sprintf("%#v", this.DefinitionId)+",\n")
	s = append(s, "RootFs: "+fmt.Sprintf("%#v", this.RootFs)+",\n")
	if this.EnvironmentVariables != nil {
		s = append(s, "EnvironmentVariables: "+fmt.Sprintf("%#v", this.EnvironmentVariables)+",\n")
	}
	if this.Setup != nil {
		s = append(s, "Setup: "+fmt.Sprintf("%#v", this.Setup)+",\n")
	}
	if this.Action != nil {
		s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	}
	s = append(s, "StartTimeoutMs: "+fmt.Sprintf("%#v", this.StartTimeoutMs)+",\n")
	s = append(s, "DeprecatedStartTimeoutS: "+fmt.Sprintf("%#v", this.DeprecatedStartTimeoutS)+",\n")
	if this.Monitor != nil {
		s = append(s, "Monitor: "+fmt.Sprintf("%#v", this.Monitor)+",\n")
	}
	s = append(s, "DiskMb: "+fmt.Sprintf("%#v", this.DiskMb)+",\n")
	s = append(s, "MemoryMb: "+fmt.Sprintf("%#v", this.MemoryMb)+",\n")
	s = append(s, "CpuWeight: "+fmt.Sprintf("%#v", this.CpuWeight)+",\n")
	s = append(s, "Privileged: "+fmt.Sprintf("%#v", this.Privileged)+",\n")
	if this.Ports != nil {
		s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	}
	s = append(s, "LogSource: "+fmt.Sprintf("%#v", this.LogSource)+",\n")
	s = append(s, "LogGuid: "+fmt.Sprintf("%#v", this.LogGuid)+",\n")
	s = append(s, "MetricsGuid: "+fmt.Sprintf("%#v", this.MetricsGuid)+",\n")
	if this.EgressRules != nil {
		s = append(s, "EgressRules: "+fmt.Sprintf("%#v", this.EgressRules)+",\n")
	}
	if this.CachedDependencies != nil {
		s = append(s, "CachedDependencies: "+fmt.Sprintf("%#v", this.CachedDependencies)+",\n")
	}
	s = append(s, "LegacyDownloadUser: "+fmt.Sprintf("%#v", this.LegacyDownloadUser)+",\n")
	s = append(s, "TrustedSystemCertificatesPath: "+fmt.Sprintf("%#v", this.TrustedSystemCertificatesPath)+",\n")
	if this.VolumePlacement != nil {
		s = append(s, "VolumePlacement: "+fmt.Sprintf("%#v", this.VolumePlacement)+",\n")
	}
	if this.VolumeMounts != nil {
		s = append(s, "VolumeMounts: "+fmt.Sprintf("%#v", this.VolumeMounts)+",\n")
	}
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	if this.PlacementTags != nil {
		s = append(s, "PlacementTags: "+fmt.Sprintf("%#v", this.PlacementTags)+",\n")
	}
	s = append(s, "MaxPids: "+fmt.Sprintf("%#v", this.MaxPids)+",\n")
	if this.CertificateProperties != nil {
		s = append(s, "CertificateProperties: "+fmt.Sprintf("%#v", this.CertificateProperties)+",\n")
	}
	s = append(s, "ImageUsername: "+fmt.Sprintf("%#v", this.ImageUsername)+",\n")
	s = append(s, "ImagePassword: "+fmt.Sprintf("%#v", this.ImagePassword)+",\n")
	if this.CheckDefinition != nil {
		s = append(s, "CheckDefinition: "+fmt.Sprintf("%#v", this.CheckDefinition)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringLrpDeployment(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *LRPDeployment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LRPDeployment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.ProcessGuid)))
	i += copy(dAtA[i:], m.ProcessGuid)
	dAtA[i] = 0x12
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.Domain)))
	i += copy(dAtA[i:], m.Domain)
	dAtA[i] = 0x18
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(m.Instances))
	dAtA[i] = 0x22
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.Annotation)))
	i += copy(dAtA[i:], m.Annotation)
	if m.Routes != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(m.Routes.Size()))
		n1, err := m.Routes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Definitions) > 0 {
		for k, _ := range m.Definitions {
			dAtA[i] = 0x32
			i++
			v := m.Definitions[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovLrpDeployment(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovLrpDeployment(uint64(len(k))) + msgSize
			i = encodeVarintLrpDeployment(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintLrpDeployment(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintLrpDeployment(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.ActiveDefinitionId)))
	i += copy(dAtA[i:], m.ActiveDefinitionId)
	dAtA[i] = 0x42
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.HealthyDefinitionId)))
	i += copy(dAtA[i:], m.HealthyDefinitionId)
	if m.ModificationTag != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(m.ModificationTag.Size()))
		n3, err := m.ModificationTag.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *LRPDeploymentCreation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LRPDeploymentCreation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.ProcessGuid)))
	i += copy(dAtA[i:], m.ProcessGuid)
	dAtA[i] = 0x12
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.Domain)))
	i += copy(dAtA[i:], m.Domain)
	dAtA[i] = 0x18
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(m.Instances))
	dAtA[i] = 0x22
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.Annotation)))
	i += copy(dAtA[i:], m.Annotation)
	if m.Routes != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(m.Routes.Size()))
		n4, err := m.Routes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.DefinitionId)))
	i += copy(dAtA[i:], m.DefinitionId)
	if m.Definition != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(m.Definition.Size()))
		n5, err := m.Definition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *LRPDeploymentUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LRPDeploymentUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Instances != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(*m.Instances))
	}
	if m.Annotation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(len(*m.Annotation)))
		i += copy(dAtA[i:], *m.Annotation)
	}
	if m.Routes != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(m.Routes.Size()))
		n6, err := m.Routes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.DefinitionId != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(len(*m.DefinitionId)))
		i += copy(dAtA[i:], *m.DefinitionId)
	}
	if m.Definition != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(m.Definition.Size()))
		n7, err := m.Definition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *LRPDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LRPDefinition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.DefinitionId)))
	i += copy(dAtA[i:], m.DefinitionId)
	dAtA[i] = 0x12
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.RootFs)))
	i += copy(dAtA[i:], m.RootFs)
	if len(m.EnvironmentVariables) > 0 {
		for _, msg := range m.EnvironmentVariables {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintLrpDeployment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Setup != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(m.Setup.Size()))
		n8, err := m.Setup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Action != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(m.Action.Size()))
		n9, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	dAtA[i] = 0x30
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(m.StartTimeoutMs))
	dAtA[i] = 0x38
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(m.DeprecatedStartTimeoutS))
	if m.Monitor != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(m.Monitor.Size()))
		n10, err := m.Monitor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	dAtA[i] = 0x48
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(m.DiskMb))
	dAtA[i] = 0x50
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(m.MemoryMb))
	dAtA[i] = 0x58
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(m.CpuWeight))
	dAtA[i] = 0x60
	i++
	if m.Privileged {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Ports) > 0 {
		for _, num := range m.Ports {
			dAtA[i] = 0x68
			i++
			i = encodeVarintLrpDeployment(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x72
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.LogSource)))
	i += copy(dAtA[i:], m.LogSource)
	dAtA[i] = 0x7a
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.LogGuid)))
	i += copy(dAtA[i:], m.LogGuid)
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.MetricsGuid)))
	i += copy(dAtA[i:], m.MetricsGuid)
	if len(m.EgressRules) > 0 {
		for _, msg := range m.EgressRules {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintLrpDeployment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CachedDependencies) > 0 {
		for _, msg := range m.CachedDependencies {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintLrpDeployment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x9a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.LegacyDownloadUser)))
	i += copy(dAtA[i:], m.LegacyDownloadUser)
	dAtA[i] = 0xa2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.TrustedSystemCertificatesPath)))
	i += copy(dAtA[i:], m.TrustedSystemCertificatesPath)
	if m.VolumePlacement != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(m.VolumePlacement.Size()))
		n11, err := m.VolumePlacement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.VolumeMounts) > 0 {
		for _, msg := range m.VolumeMounts {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintLrpDeployment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Network != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(m.Network.Size()))
		n12, err := m.Network.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.PlacementTags) > 0 {
		for _, s := range m.PlacementTags {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0xc8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(m.MaxPids))
	if m.CertificateProperties != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(m.CertificateProperties.Size()))
		n13, err := m.CertificateProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	dAtA[i] = 0xda
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.ImageUsername)))
	i += copy(dAtA[i:], m.ImageUsername)
	dAtA[i] = 0xe2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintLrpDeployment(dAtA, i, uint64(len(m.ImagePassword)))
	i += copy(dAtA[i:], m.ImagePassword)
	if m.CheckDefinition != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLrpDeployment(dAtA, i, uint64(m.CheckDefinition.Size()))
		n14, err := m.CheckDefinition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func encodeFixed64LrpDeployment(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32LrpDeployment(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintLrpDeployment(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LRPDeployment) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProcessGuid)
	n += 1 + l + sovLrpDeployment(uint64(l))
	l = len(m.Domain)
	n += 1 + l + sovLrpDeployment(uint64(l))
	n += 1 + sovLrpDeployment(uint64(m.Instances))
	l = len(m.Annotation)
	n += 1 + l + sovLrpDeployment(uint64(l))
	if m.Routes != nil {
		l = m.Routes.Size()
		n += 1 + l + sovLrpDeployment(uint64(l))
	}
	if len(m.Definitions) > 0 {
		for k, v := range m.Definitions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovLrpDeployment(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovLrpDeployment(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovLrpDeployment(uint64(mapEntrySize))
		}
	}
	l = len(m.ActiveDefinitionId)
	n += 1 + l + sovLrpDeployment(uint64(l))
	l = len(m.HealthyDefinitionId)
	n += 1 + l + sovLrpDeployment(uint64(l))
	if m.ModificationTag != nil {
		l = m.ModificationTag.Size()
		n += 1 + l + sovLrpDeployment(uint64(l))
	}
	return n
}

func (m *LRPDeploymentCreation) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProcessGuid)
	n += 1 + l + sovLrpDeployment(uint64(l))
	l = len(m.Domain)
	n += 1 + l + sovLrpDeployment(uint64(l))
	n += 1 + sovLrpDeployment(uint64(m.Instances))
	l = len(m.Annotation)
	n += 1 + l + sovLrpDeployment(uint64(l))
	if m.Routes != nil {
		l = m.Routes.Size()
		n += 1 + l + sovLrpDeployment(uint64(l))
	}
	l = len(m.DefinitionId)
	n += 1 + l + sovLrpDeployment(uint64(l))
	if m.Definition != nil {
		l = m.Definition.Size()
		n += 1 + l + sovLrpDeployment(uint64(l))
	}
	return n
}

func (m *LRPDeploymentUpdate) Size() (n int) {
	var l int
	_ = l
	if m.Instances != nil {
		n += 1 + sovLrpDeployment(uint64(*m.Instances))
	}
	if m.Annotation != nil {
		l = len(*m.Annotation)
		n += 1 + l + sovLrpDeployment(uint64(l))
	}
	if m.Routes != nil {
		l = m.Routes.Size()
		n += 1 + l + sovLrpDeployment(uint64(l))
	}
	if m.DefinitionId != nil {
		l = len(*m.DefinitionId)
		n += 1 + l + sovLrpDeployment(uint64(l))
	}
	if m.Definition != nil {
		l = m.Definition.Size()
		n += 1 + l + sovLrpDeployment(uint64(l))
	}
	return n
}

func (m *LRPDefinition) Size() (n int) {
	var l int
	_ = l
	l = len(m.DefinitionId)
	n += 1 + l + sovLrpDeployment(uint64(l))
	l = len(m.RootFs)
	n += 1 + l + sovLrpDeployment(uint64(l))
	if len(m.EnvironmentVariables) > 0 {
		for _, e := range m.EnvironmentVariables {
			l = e.Size()
			n += 1 + l + sovLrpDeployment(uint64(l))
		}
	}
	if m.Setup != nil {
		l = m.Setup.Size()
		n += 1 + l + sovLrpDeployment(uint64(l))
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovLrpDeployment(uint64(l))
	}
	n += 1 + sovLrpDeployment(uint64(m.StartTimeoutMs))
	n += 1 + sovLrpDeployment(uint64(m.DeprecatedStartTimeoutS))
	if m.Monitor != nil {
		l = m.Monitor.Size()
		n += 1 + l + sovLrpDeployment(uint64(l))
	}
	n += 1 + sovLrpDeployment(uint64(m.DiskMb))
	n += 1 + sovLrpDeployment(uint64(m.MemoryMb))
	n += 1 + sovLrpDeployment(uint64(m.CpuWeight))
	n += 2
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			n += 1 + sovLrpDeployment(uint64(e))
		}
	}
	l = len(m.LogSource)
	n += 1 + l + sovLrpDeployment(uint64(l))
	l = len(m.LogGuid)
	n += 1 + l + sovLrpDeployment(uint64(l))
	l = len(m.MetricsGuid)
	n += 2 + l + sovLrpDeployment(uint64(l))
	if len(m.EgressRules) > 0 {
		for _, e := range m.EgressRules {
			l = e.Size()
			n += 2 + l + sovLrpDeployment(uint64(l))
		}
	}
	if len(m.CachedDependencies) > 0 {
		for _, e := range m.CachedDependencies {
			l = e.Size()
			n += 2 + l + sovLrpDeployment(uint64(l))
		}
	}
	l = len(m.LegacyDownloadUser)
	n += 2 + l + sovLrpDeployment(uint64(l))
	l = len(m.TrustedSystemCertificatesPath)
	n += 2 + l + sovLrpDeployment(uint64(l))
	if m.VolumePlacement != nil {
		l = m.VolumePlacement.Size()
		n += 2 + l + sovLrpDeployment(uint64(l))
	}
	if len(m.VolumeMounts) > 0 {
		for _, e := range m.VolumeMounts {
			l = e.Size()
			n += 2 + l + sovLrpDeployment(uint64(l))
		}
	}
	if m.Network != nil {
		l = m.Network.Size()
		n += 2 + l + sovLrpDeployment(uint64(l))
	}
	if len(m.PlacementTags) > 0 {
		for _, s := range m.PlacementTags {
			l = len(s)
			n += 2 + l + sovLrpDeployment(uint64(l))
		}
	}
	n += 2 + sovLrpDeployment(uint64(m.MaxPids))
	if m.CertificateProperties != nil {
		l = m.CertificateProperties.Size()
		n += 2 + l + sovLrpDeployment(uint64(l))
	}
	l = len(m.ImageUsername)
	n += 2 + l + sovLrpDeployment(uint64(l))
	l = len(m.ImagePassword)
	n += 2 + l + sovLrpDeployment(uint64(l))
	if m.CheckDefinition != nil {
		l = m.CheckDefinition.Size()
		n += 2 + l + sovLrpDeployment(uint64(l))
	}
	return n
}

func sovLrpDeployment(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLrpDeployment(x uint64) (n int) {
	return sovLrpDeployment(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *LRPDeployment) String() string {
	if this == nil {
		return "nil"
	}
	keysForDefinitions := make([]string, 0, len(this.Definitions))
	for k, _ := range this.Definitions {
		keysForDefinitions = append(keysForDefinitions, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDefinitions)
	mapStringForDefinitions := "map[string]*LRPDefinition{"
	for _, k := range keysForDefinitions {
		mapStringForDefinitions += fmt.Sprintf("%v: %v,", k, this.Definitions[k])
	}
	mapStringForDefinitions += "}"
	s := strings.Join([]string{`&LRPDeployment{`,
		`ProcessGuid:` + fmt.Sprintf("%v", this.ProcessGuid) + `,`,
		`Domain:` + fmt.Sprintf("%v", this.Domain) + `,`,
		`Instances:` + fmt.Sprintf("%v", this.Instances) + `,`,
		`Annotation:` + fmt.Sprintf("%v", this.Annotation) + `,`,
		`Routes:` + valueToStringLrpDeployment(this.Routes) + `,`,
		`Definitions:` + mapStringForDefinitions + `,`,
		`ActiveDefinitionId:` + fmt.Sprintf("%v", this.ActiveDefinitionId) + `,`,
		`HealthyDefinitionId:` + fmt.Sprintf("%v", this.HealthyDefinitionId) + `,`,
		`ModificationTag:` + strings.Replace(fmt.Sprintf("%v", this.ModificationTag), "ModificationTag", "ModificationTag", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LRPDeploymentCreation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LRPDeploymentCreation{`,
		`ProcessGuid:` + fmt.Sprintf("%v", this.ProcessGuid) + `,`,
		`Domain:` + fmt.Sprintf("%v", this.Domain) + `,`,
		`Instances:` + fmt.Sprintf("%v", this.Instances) + `,`,
		`Annotation:` + fmt.Sprintf("%v", this.Annotation) + `,`,
		`Routes:` + valueToStringLrpDeployment(this.Routes) + `,`,
		`DefinitionId:` + fmt.Sprintf("%v", this.DefinitionId) + `,`,
		`Definition:` + strings.Replace(fmt.Sprintf("%v", this.Definition), "LRPDefinition", "LRPDefinition", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LRPDeploymentUpdate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LRPDeploymentUpdate{`,
		`Instances:` + valueToStringLrpDeployment(this.Instances) + `,`,
		`Annotation:` + valueToStringLrpDeployment(this.Annotation) + `,`,
		`Routes:` + valueToStringLrpDeployment(this.Routes) + `,`,
		`DefinitionId:` + valueToStringLrpDeployment(this.DefinitionId) + `,`,
		`Definition:` + strings.Replace(fmt.Sprintf("%v", this.Definition), "LRPDefinition", "LRPDefinition", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LRPDefinition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LRPDefinition{`,
		`DefinitionId:` + fmt.Sprintf("%v", this.DefinitionId) + `,`,
		`RootFs:` + fmt.Sprintf("%v", this.RootFs) + `,`,
		`EnvironmentVariables:` + strings.Replace(fmt.Sprintf("%v", this.EnvironmentVariables), "EnvironmentVariable", "EnvironmentVariable", 1) + `,`,
		`Setup:` + strings.Replace(fmt.Sprintf("%v", this.Setup), "Action", "Action", 1) + `,`,
		`Action:` + strings.Replace(fmt.Sprintf("%v", this.Action), "Action", "Action", 1) + `,`,
		`StartTimeoutMs:` + fmt.Sprintf("%v", this.StartTimeoutMs) + `,`,
		`DeprecatedStartTimeoutS:` + fmt.Sprintf("%v", this.DeprecatedStartTimeoutS) + `,`,
		`Monitor:` + strings.Replace(fmt.Sprintf("%v", this.Monitor), "Action", "Action", 1) + `,`,
		`DiskMb:` + fmt.Sprintf("%v", this.DiskMb) + `,`,
		`MemoryMb:` + fmt.Sprintf("%v", this.MemoryMb) + `,`,
		`CpuWeight:` + fmt.Sprintf("%v", this.CpuWeight) + `,`,
		`Privileged:` + fmt.Sprintf("%v", this.Privileged) + `,`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`LogSource:` + fmt.Sprintf("%v", this.LogSource) + `,`,
		`LogGuid:` + fmt.Sprintf("%v", this.LogGuid) + `,`,
		`MetricsGuid:` + fmt.Sprintf("%v", this.MetricsGuid) + `,`,
		`EgressRules:` + strings.Replace(fmt.Sprintf("%v", this.EgressRules), "SecurityGroupRule", "SecurityGroupRule", 1) + `,`,
		`CachedDependencies:` + strings.Replace(fmt.Sprintf("%v", this.CachedDependencies), "CachedDependency", "CachedDependency", 1) + `,`,
		`LegacyDownloadUser:` + fmt.Sprintf("%v", this.LegacyDownloadUser) + `,`,
		`TrustedSystemCertificatesPath:` + fmt.Sprintf("%v", this.TrustedSystemCertificatesPath) + `,`,
		`VolumePlacement:` + strings.Replace(fmt.Sprintf("%v", this.VolumePlacement), "VolumePlacement", "VolumePlacement", 1) + `,`,
		`VolumeMounts:` + strings.Replace(fmt.Sprintf("%v", this.VolumeMounts), "VolumeMount", "VolumeMount", 1) + `,`,
		`Network:` + strings.Replace(fmt.Sprintf("%v", this.Network), "Network", "Network", 1) + `,`,
		`PlacementTags:` + fmt.Sprintf("%v", this.PlacementTags) + `,`,
		`MaxPids:` + fmt.Sprintf("%v", this.MaxPids) + `,`,
		`CertificateProperties:` + strings.Replace(fmt.Sprintf("%v", this.CertificateProperties), "CertificateProperties", "CertificateProperties", 1) + `,`,
		`ImageUsername:` + fmt.Sprintf("%v", this.ImageUsername) + `,`,
		`ImagePassword:` + fmt.Sprintf("%v", this.ImagePassword) + `,`,
		`CheckDefinition:` + strings.Replace(fmt.Sprintf("%v", this.CheckDefinition), "CheckDefinition", "CheckDefinition", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringLrpDeployment(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *LRPDeployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLrpDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LRPDeployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LRPDeployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessGuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessGuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			m.Instances = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Instances |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routes == nil {
				m.Routes = &Routes{}
			}
			if err := m.Routes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Definitions == nil {
				m.Definitions = make(map[string]*LRPDefinition)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLrpDeployment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLrpDeployment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthLrpDeployment
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthLrpDeployment
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &LRPDefinition{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Definitions[mapkey] = mapvalue
			} else {
				var mapvalue *LRPDefinition
				m.Definitions[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveDefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthyDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthyDefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModificationTag == nil {
				m.ModificationTag = &ModificationTag{}
			}
			if err := m.ModificationTag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLrpDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LRPDeploymentCreation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLrpDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LRPDeploymentCreation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LRPDeploymentCreation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessGuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessGuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			m.Instances = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Instances |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routes == nil {
				m.Routes = &Routes{}
			}
			if err := m.Routes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Definition == nil {
				m.Definition = &LRPDefinition{}
			}
			if err := m.Definition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLrpDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LRPDeploymentUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLrpDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LRPDeploymentUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LRPDeploymentUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Instances = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Annotation = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routes == nil {
				m.Routes = &Routes{}
			}
			if err := m.Routes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DefinitionId = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Definition == nil {
				m.Definition = &LRPDefinition{}
			}
			if err := m.Definition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLrpDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LRPDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLrpDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LRPDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LRPDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootFs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootFs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvironmentVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvironmentVariables = append(m.EnvironmentVariables, &EnvironmentVariable{})
			if err := m.EnvironmentVariables[len(m.EnvironmentVariables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Setup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Setup == nil {
				m.Setup = &Action{}
			}
			if err := m.Setup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &Action{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeoutMs", wireType)
			}
			m.StartTimeoutMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeoutMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedStartTimeoutS", wireType)
			}
			m.DeprecatedStartTimeoutS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedStartTimeoutS |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monitor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Monitor == nil {
				m.Monitor = &Action{}
			}
			if err := m.Monitor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskMb", wireType)
			}
			m.DiskMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskMb |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryMb", wireType)
			}
			m.MemoryMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryMb |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuWeight", wireType)
			}
			m.CpuWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuWeight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 13:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLrpDeployment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ports = append(m.Ports, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLrpDeployment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLrpDeployment
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLrpDeployment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ports = append(m.Ports, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogGuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogGuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsGuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricsGuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressRules = append(m.EgressRules, &SecurityGroupRule{})
			if err := m.EgressRules[len(m.EgressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedDependencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CachedDependencies = append(m.CachedDependencies, &CachedDependency{})
			if err := m.CachedDependencies[len(m.CachedDependencies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyDownloadUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LegacyDownloadUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedSystemCertificatesPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedSystemCertificatesPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumePlacement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumePlacement == nil {
				m.VolumePlacement = &VolumePlacement{}
			}
			if err := m.VolumePlacement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeMounts = append(m.VolumeMounts, &VolumeMount{})
			if err := m.VolumeMounts[len(m.VolumeMounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &Network{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlacementTags = append(m.PlacementTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPids", wireType)
			}
			m.MaxPids = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPids |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CertificateProperties == nil {
				m.CertificateProperties = &CertificateProperties{}
			}
			if err := m.CertificateProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CheckDefinition == nil {
				m.CheckDefinition = &CheckDefinition{}
			}
			if err := m.CheckDefinition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLrpDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLrpDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLrpDeployment(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLrpDeployment
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLrpDeployment
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthLrpDeployment
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLrpDeployment
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLrpDeployment(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLrpDeployment = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLrpDeployment   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("lrp_deployment.proto", fileDescriptorLrpDeployment) }

var fileDescriptorLrpDeployment = []byte{
	// 1353 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x56, 0x41, 0x6f, 0x1b, 0xc5,
	0x17, 0xcf, 0xc6, 0x89, 0x9d, 0x8c, 0xe3, 0x24, 0x9d, 0xd8, 0xc9, 0xd4, 0x49, 0x6c, 0x37, 0xff,
	0xbf, 0x5a, 0x17, 0x4a, 0x2a, 0x45, 0x02, 0x55, 0x94, 0x03, 0x38, 0x29, 0x05, 0x89, 0x20, 0xcb,
	0x69, 0x0a, 0x88, 0xc3, 0x6a, 0xbd, 0x3b, 0x59, 0x8f, 0xb2, 0xbb, 0xb3, 0x9a, 0x99, 0x75, 0x6a,
	0x21, 0x21, 0x0e, 0x7c, 0x00, 0x3e, 0x06, 0x9f, 0x01, 0x71, 0xa7, 0xc7, 0x1e, 0x11, 0x07, 0x8b,
	0x9a, 0x0b, 0xf2, 0xa9, 0x1f, 0x01, 0xed, 0xec, 0xac, 0x3d, 0xeb, 0x38, 0x70, 0xe1, 0xc4, 0x6d,
	0xe7, 0xfd, 0x7e, 0xef, 0xbd, 0x79, 0xbf, 0x79, 0xfb, 0x66, 0x40, 0xd9, 0x63, 0xa1, 0xe9, 0xe0,
	0xd0, 0xa3, 0x03, 0x1f, 0x07, 0xe2, 0x30, 0x64, 0x54, 0x50, 0x98, 0xf7, 0xa9, 0x83, 0x3d, 0x5e,
	0x7d, 0xc7, 0x25, 0xa2, 0x17, 0x75, 0x0f, 0x6d, 0xea, 0x3f, 0x74, 0xa9, 0x4b, 0x1f, 0x4a, 0xb8,
	0x1b, 0x5d, 0xc8, 0x95, 0x5c, 0xc8, 0xaf, 0xc4, 0xad, 0x5a, 0xb2, 0x6c, 0x41, 0x68, 0xc0, 0xd5,
	0x72, 0xc7, 0xb6, 0xec, 0x1e, 0x76, 0xe2, 0xf0, 0x38, 0x70, 0x70, 0x60, 0x0f, 0x14, 0xb0, 0x67,
	0x63, 0x26, 0xc8, 0x05, 0xb1, 0x2d, 0x81, 0xcd, 0x90, 0xd1, 0x30, 0x5e, 0xe2, 0xd4, 0x6d, 0x17,
	0x07, 0x7d, 0xc2, 0x68, 0x10, 0xef, 0xc7, 0xec, 0x5b, 0x8c, 0x58, 0x5d, 0x6f, 0x02, 0x6e, 0xfb,
	0xd4, 0x49, 0x3c, 0x09, 0x0d, 0x4c, 0x61, 0xb9, 0x69, 0xea, 0x00, 0x8b, 0x2b, 0xca, 0x2e, 0xd5,
	0xb2, 0xcc, 0xb1, 0x1d, 0x31, 0x22, 0x06, 0xa6, 0xcb, 0x68, 0x14, 0x2a, 0x2b, 0xec, 0x53, 0x2f,
	0xf2, 0xb1, 0xe9, 0xd3, 0x28, 0x2d, 0xb5, 0xba, 0x6d, 0xf7, 0xb0, 0x7d, 0x69, 0x3a, 0xf8, 0x82,
	0x04, 0x24, 0x0e, 0xaa, 0xec, 0xb7, 0x1c, 0xcc, 0x09, 0xc3, 0x8e, 0xe9, 0x31, 0xe5, 0x7e, 0xf0,
	0xd3, 0x12, 0x28, 0x7d, 0xd6, 0x69, 0x9f, 0x4c, 0xd4, 0x82, 0xf7, 0xc0, 0x5a, 0xc8, 0xa8, 0x8d,
	0x39, 0x37, 0xdd, 0x88, 0x38, 0xc8, 0x68, 0x18, 0xcd, 0xd5, 0xd6, 0xd2, 0xcb, 0x61, 0x7d, 0xa1,
	0x53, 0x54, 0xc8, 0xd3, 0x88, 0x38, 0x70, 0x0f, 0xe4, 0x1d, 0xea, 0x5b, 0x24, 0x40, 0x8b, 0x1a,
	0x45, 0xd9, 0xe0, 0x01, 0x58, 0x25, 0x01, 0x17, 0x56, 0x60, 0x63, 0x8e, 0x72, 0x0d, 0xa3, 0xb9,
	0xac, 0x08, 0x53, 0x33, 0xfc, 0x3f, 0x00, 0x56, 0x10, 0x50, 0x21, 0x0b, 0x47, 0x4b, 0x5a, 0x14,
	0xcd, 0x0e, 0x1f, 0x83, 0x3c, 0xa3, 0x91, 0xc0, 0x1c, 0x2d, 0x37, 0x8c, 0x66, 0xf1, 0x68, 0xeb,
	0x30, 0x39, 0xc9, 0xc3, 0x76, 0x5c, 0x41, 0x47, 0x42, 0xad, 0xf5, 0x97, 0xc3, 0xba, 0xf1, 0xdb,
	0xb0, 0x9e, 0x4f, 0xd6, 0x1d, 0xe5, 0x02, 0x3f, 0x01, 0xc5, 0xa9, 0x0c, 0x1c, 0xe5, 0x1b, 0xb9,
	0x66, 0xf1, 0xe8, 0x6e, 0x1a, 0x21, 0x53, 0xf9, 0xe1, 0xc9, 0x94, 0xf8, 0x24, 0x10, 0x6c, 0xd0,
	0xd1, 0x5d, 0xe1, 0x7b, 0xa0, 0x1c, 0xb7, 0x42, 0x1f, 0x6b, 0xba, 0x9a, 0xc4, 0x41, 0x05, 0x6d,
	0xdb, 0x30, 0x61, 0x4c, 0x03, 0x7d, 0xea, 0xc0, 0x47, 0xa0, 0xd2, 0xc3, 0x96, 0x27, 0x7a, 0x83,
	0x19, 0xc7, 0x15, 0xcd, 0x71, 0x4b, 0x51, 0x32, 0x9e, 0x2d, 0xb0, 0x39, 0xdb, 0x19, 0x68, 0x55,
	0x4a, 0xb0, 0x93, 0x16, 0x70, 0xaa, 0xe1, 0xcf, 0x2c, 0xb7, 0xb3, 0xe1, 0x67, 0x0d, 0xd5, 0xaf,
	0xc1, 0xe6, 0x6c, 0x59, 0x70, 0x1b, 0xe4, 0x2e, 0xf1, 0x20, 0x73, 0xb0, 0xb1, 0x01, 0xbe, 0x0d,
	0x96, 0xfb, 0x96, 0x17, 0x61, 0x79, 0x9e, 0xc5, 0xa3, 0x4a, 0x46, 0xa5, 0x34, 0x46, 0x27, 0xe1,
	0xbc, 0xbf, 0xf8, 0xc8, 0x38, 0xf8, 0x65, 0x11, 0x54, 0x32, 0x12, 0x1e, 0x33, 0x9c, 0x9c, 0xd9,
	0x7f, 0xab, 0x89, 0xee, 0x83, 0x52, 0xf6, 0xe8, 0xf2, 0x5a, 0x96, 0x35, 0x47, 0x3f, 0xb3, 0x77,
	0x01, 0x98, 0xae, 0x65, 0x6f, 0xdc, 0x28, 0xa4, 0x46, 0x3c, 0xf8, 0x7e, 0x11, 0x6c, 0x65, 0x94,
	0x3c, 0x0f, 0x1d, 0x4b, 0xe0, 0xac, 0x00, 0xc6, 0x44, 0x00, 0xe3, 0x66, 0x01, 0xa6, 0x32, 0x1a,
	0x37, 0x08, 0x90, 0xfb, 0x17, 0x04, 0x58, 0xd2, 0xb2, 0x64, 0x05, 0x78, 0x9c, 0x11, 0x60, 0xf9,
	0x6f, 0x04, 0x48, 0x37, 0xa9, 0xc9, 0xf0, 0xf3, 0xba, 0x9a, 0x46, 0xa9, 0xe5, 0x7a, 0x66, 0xe3,
	0x46, 0xe9, 0xef, 0x81, 0x02, 0xa3, 0x54, 0x98, 0x17, 0x5c, 0x89, 0x10, 0x57, 0xb3, 0x30, 0x1e,
	0xd6, 0xf3, 0xb1, 0xf9, 0x42, 0x56, 0x43, 0xc5, 0xc7, 0x1c, 0x7e, 0x05, 0x2a, 0x73, 0xc7, 0x31,
	0xca, 0xc9, 0xe9, 0xb0, 0x9b, 0xee, 0xf6, 0xc9, 0x94, 0xf4, 0x5c, 0x71, 0x5a, 0x85, 0xf1, 0xb0,
	0x9e, 0xc3, 0x41, 0xbf, 0x53, 0xc6, 0xd7, 0xd1, 0xf8, 0x2c, 0x96, 0x39, 0x16, 0x51, 0x28, 0x05,
	0x2a, 0x1e, 0xad, 0xa7, 0xa1, 0x3e, 0xb2, 0x93, 0x7f, 0x47, 0x82, 0xf0, 0x2e, 0xc8, 0x27, 0xb7,
	0x8a, 0xd2, 0x67, 0x96, 0xa6, 0x50, 0x78, 0x08, 0x36, 0xb9, 0xb0, 0x98, 0x30, 0x05, 0xf1, 0x31,
	0x8d, 0x84, 0xe9, 0x73, 0xd9, 0x7a, 0x39, 0x55, 0xff, 0xba, 0x44, 0x9f, 0x25, 0xe0, 0x29, 0x87,
	0x17, 0xa0, 0xea, 0xe0, 0x90, 0xe1, 0xf8, 0x0e, 0x72, 0xcc, 0xac, 0x2b, 0x97, 0xcd, 0x58, 0x6a,
	0xdd, 0x57, 0xa2, 0xd4, 0x35, 0x66, 0xca, 0x09, 0xf8, 0x03, 0xea, 0x13, 0x81, 0xfd, 0x50, 0x0c,
	0x90, 0xd1, 0xd9, 0x99, 0x52, 0xce, 0xb4, 0x44, 0x67, 0xb0, 0x09, 0x0a, 0x3e, 0x0d, 0x88, 0xa0,
	0x4c, 0x0e, 0xb1, 0xeb, 0x05, 0xa4, 0x30, 0xdc, 0x07, 0x05, 0x87, 0xf0, 0x4b, 0xd3, 0xef, 0xca,
	0xc9, 0xb5, 0x3c, 0xf9, 0xbf, 0x09, 0xbf, 0x3c, 0xed, 0xc2, 0x3b, 0x60, 0xd5, 0xc7, 0x3e, 0x65,
	0x83, 0x98, 0x00, 0x34, 0xc2, 0x4a, 0x62, 0x3e, 0xed, 0xc2, 0xff, 0x01, 0x60, 0x87, 0x91, 0x79,
	0x85, 0x89, 0xdb, 0x13, 0xa8, 0x28, 0x6b, 0x50, 0x33, 0xc0, 0x0e, 0xa3, 0x2f, 0xa4, 0x39, 0xfe,
	0x05, 0x42, 0x46, 0xfa, 0xc4, 0xc3, 0x2e, 0x76, 0xd0, 0x5a, 0xc3, 0x68, 0xae, 0xa4, 0x33, 0x60,
	0x6a, 0x87, 0x65, 0xb0, 0x1c, 0x52, 0x26, 0x38, 0x2a, 0x35, 0x72, 0xcd, 0x52, 0x27, 0x59, 0xc4,
	0x09, 0x3c, 0xea, 0x9a, 0x9c, 0x46, 0xcc, 0xc6, 0x68, 0x5d, 0x6b, 0xaf, 0x55, 0x8f, 0xba, 0x67,
	0xd2, 0x0c, 0xeb, 0x60, 0x25, 0x26, 0xc9, 0x59, 0xb6, 0xa1, 0x51, 0x0a, 0x1e, 0x75, 0xe5, 0x1c,
	0xbb, 0x07, 0xd6, 0x7c, 0x2c, 0x18, 0xb1, 0xd5, 0xc0, 0xdb, 0xd4, 0x07, 0x9e, 0x42, 0x24, 0xf1,
	0x03, 0xb0, 0x86, 0x5d, 0x16, 0x0f, 0x46, 0x16, 0xc5, 0x3d, 0x77, 0x4b, 0xf6, 0xdc, 0xed, 0x54,
	0xc0, 0x33, 0x75, 0xc7, 0x3f, 0x8d, 0xaf, 0xf8, 0x4e, 0xe4, 0xe1, 0x4e, 0x31, 0xa1, 0xc7, 0xdf,
	0x1c, 0x7a, 0x60, 0x6b, 0xf6, 0x01, 0x42, 0x30, 0x47, 0x50, 0x06, 0x41, 0x69, 0x90, 0x63, 0x49,
	0x39, 0x99, 0x3c, 0x51, 0x5a, 0x77, 0xc6, 0xc3, 0xfa, 0xfe, 0x1c, 0xc7, 0xe9, 0x71, 0x77, 0xa0,
	0x9d, 0x75, 0x22, 0x98, 0xc3, 0x2f, 0x41, 0xd9, 0xc3, 0xae, 0x65, 0x0f, 0x4c, 0x87, 0x5e, 0x05,
	0x1e, 0xb5, 0x1c, 0x33, 0xe2, 0x98, 0xa1, 0x2d, 0x59, 0xdc, 0x5d, 0xd5, 0x49, 0xb5, 0x79, 0x1c,
	0x3d, 0x72, 0x82, 0x9f, 0x28, 0xf8, 0x9c, 0x63, 0x06, 0xbf, 0x01, 0x0d, 0xc1, 0x22, 0x2e, 0xdb,
	0x74, 0xc0, 0x05, 0xf6, 0x4d, 0xed, 0xf9, 0xc4, 0xcd, 0xd0, 0x12, 0x3d, 0x54, 0x96, 0x59, 0x8e,
	0x54, 0x96, 0xb7, 0xfe, 0x89, 0xaf, 0x65, 0xdc, 0x57, 0xdc, 0x33, 0x49, 0x3d, 0xd6, 0x98, 0x6d,
	0x4b, 0xf4, 0x60, 0x17, 0x6c, 0xaa, 0x47, 0x53, 0xe8, 0x59, 0x36, 0x8e, 0xff, 0x60, 0x54, 0xc9,
	0xde, 0xab, 0xcf, 0x25, 0xde, 0x4e, 0xe1, 0x56, 0x6d, 0x3c, 0xac, 0x57, 0x67, 0x9d, 0xb4, 0x8c,
	0x1b, 0xfd, 0xac, 0x03, 0x3c, 0x07, 0x25, 0xfd, 0x61, 0xc6, 0xd1, 0xb6, 0x3c, 0xa2, 0xad, 0x6c,
	0x82, 0xd3, 0x18, 0x6b, 0xed, 0x8e, 0x87, 0xf5, 0x9d, 0x0c, 0x5b, 0x8b, 0xbc, 0xd6, 0x9f, 0x32,
	0x39, 0xfc, 0x10, 0x14, 0xd4, 0xa3, 0x10, 0xed, 0xc8, 0x1d, 0x6f, 0xa4, 0x01, 0x3f, 0x4f, 0xcc,
	0xad, 0xca, 0x78, 0x58, 0xbf, 0xa5, 0x38, 0x5a, 0x98, 0xd4, 0x0d, 0x1e, 0x83, 0xf5, 0x49, 0x01,
	0xf1, 0x8b, 0x82, 0x23, 0xd4, 0xc8, 0x35, 0x57, 0x5b, 0x7b, 0xe3, 0x61, 0x1d, 0x65, 0x11, 0xcd,
	0xbd, 0x34, 0x41, 0x9e, 0x59, 0x2e, 0x8f, 0x7f, 0x07, 0xdf, 0x7a, 0x61, 0x86, 0xc4, 0xe1, 0xe8,
	0xb6, 0xf6, 0xdb, 0x16, 0x7c, 0xeb, 0x45, 0x9b, 0x38, 0x1c, 0x7e, 0x0b, 0xb6, 0xe7, 0xbf, 0x87,
	0x51, 0x55, 0x6e, 0x7b, 0x7f, 0xd2, 0xaa, 0x53, 0x56, 0x7b, 0x42, 0x6a, 0x35, 0xe3, 0x9b, 0x61,
	0x3c, 0xac, 0x37, 0xe6, 0x07, 0xd1, 0x36, 0x56, 0xb1, 0xe7, 0x05, 0x80, 0x4f, 0xc1, 0x3a, 0xf1,
	0x2d, 0x17, 0xcb, 0x5e, 0x0c, 0x2c, 0x1f, 0xa3, 0x5d, 0xd9, 0x4d, 0x0d, 0xd5, 0x4d, 0x28, 0x8b,
	0xea, 0x95, 0x4a, 0xe4, 0x5c, 0x01, 0xd3, 0x40, 0xa1, 0xc5, 0xf9, 0x15, 0x65, 0x0e, 0xda, 0x9b,
	0x17, 0x28, 0x45, 0xaf, 0x05, 0x6a, 0x2b, 0x20, 0x6e, 0xba, 0xd9, 0x57, 0x39, 0xda, 0xcf, 0x36,
	0xdd, 0x71, 0x8c, 0x6b, 0xf7, 0xa3, 0x6c, 0xba, 0x59, 0x27, 0xbd, 0xe9, 0xec, 0x19, 0x87, 0x07,
	0xaf, 0x5e, 0xd7, 0x16, 0x7e, 0x7d, 0x5d, 0x5b, 0x78, 0xf3, 0xba, 0x66, 0x7c, 0x37, 0xaa, 0x19,
	0x3f, 0x8e, 0x6a, 0xc6, 0xcb, 0x51, 0xcd, 0x78, 0x35, 0xaa, 0x19, 0xbf, 0x8f, 0x6a, 0xc6, 0x9f,
	0xa3, 0xda, 0xc2, 0x9b, 0x51, 0xcd, 0xf8, 0xe1, 0x8f, 0xda, 0xc2, 0x5f, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x10, 0xa4, 0x20, 0xdc, 0x27, 0x0d, 0x00, 0x00,
}
